<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>MapLibre Terrain Visualization</title>
    <link href="https://unpkg.com/maplibre-gl@v5.0.0-pre.9/dist/maplibre-gl.css" rel="stylesheet" />
    <script src="https://unpkg.com/maplibre-gl@v5.0.0-pre.9/dist/maplibre-gl.js"></script>
    <script src="https://unpkg.com/maplibre-contour@0.0.5/dist/index.min.js"></script>
    <script src="https://unpkg.com/@turf/turf@6/turf.min.js"></script>
    <style>
        body { margin: 0; padding: 0; }
        #map { position: absolute; top: 0; bottom: 0; width: 100%; height: 100%; }
        .layer-control {
            position: fixed;
            top: 10px;
            left: 10px;
            background: rgba(255, 255, 255, 0.9);
            padding: 10px;
            z-index: 1000;
            max-height: 90vh;
            overflow-y: auto;
            font-family: Arial, sans-serif;
            font-size: 14px;
            border: 1px solid #ccc;
            border-radius: 4px;
        }
        .layer-control h3 {
            margin-top: 0;
        }
        .layer-control label {
            display: block;
            margin-bottom: 5px;
        }
        .layer-control strong {
            display: block;
            margin-top: 10px;
            margin-bottom: 5px;
        }
        .loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 255, 255, 0.9);
            padding: 20px;
            border-radius: 4px;
            display: none;
        }
        .carousel-container {
            position: relative;
            width: 100%;
            margin: 10px 0;
        }

        .carousel-slide {
            display: none;
            position: absolute;
            width: 100%;
            z-index: 1;
            transition: opacity 2.5s ease;
        }

        .carousel-slide.active {
            display: block;
            z-index: 2;
        }

        .carousel-slide:not(.active) {
            opacity: 0;
        }

        .carousel-slide img {
            width: 100%;
            height: 200px;
            object-fit: cover;
            border-radius: 4px;
        }

        .carousel-buttons {
            position: absolute;
            bottom: 10px;
            width: 100%;
            display: flex;
            justify-content: center;
            gap: 10px;
        }

        .carousel-button {
            background: rgba(255, 255, 255, 0.8);
            border: none;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            cursor: pointer;
            font-size: 16px;
        }

        .carousel-counter {
            background: rgba(255, 255, 255, 0.8);
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 12px;
        }
    </style>
</head>
<body>
    <div id="map"></div>
    <div class="layer-control">
        <h3>Layers</h3>
        <label><input type="checkbox" id="orthophotos-checkbox" checked> Orthophotos</label>
        <label><input type="checkbox" id="snow-checkbox"> Snow layer</label>
        <label><input type="checkbox" id="planIGN-checkbox"> Plan IGN v2</label>
        <label><input type="checkbox" id="sentinel2-checkbox"> Sentinel-2 True Ortho</label>
        <label><input type="checkbox" id="buildings-checkbox" checked> 3D Buildings</label>
        <label><input type="checkbox" id="hd-terrain-checkbox"> HD Terrain</label>
        <label><input type="checkbox" id="contours-checkbox"> Contour Lines</label>
    </div>
    <div id="loading" class="loading">Loading terrain data...</div>
    
    <script>
// Initialize DEM source first
const demSource = new mlcontour.DemSource({
    url: "https://s3.amazonaws.com/elevation-tiles-prod/terrarium/{z}/{x}/{y}.png",
    encoding: "terrarium",
    maxzoom: 14,
    worker: true
});

// Initialize MapLibre Map
const map = new maplibregl.Map({
    container: 'map',
    style: {
        version: 8,
        glyphs: 'https://demotiles.maplibre.org/font/{fontstack}/{range}.pbf',
        light: {
            anchor: 'viewport',
            color: '#ffffff',  // Changed to white
            intensity: 0.2,
            position: [100.2, 90, 5]
        },
        sources: {
            'terrain-source': {
                type: 'raster-dem',
                tiles: ['/terrain_{z}_{x}_{y}.png'],
                tileSize: 1024,
                maxzoom: 17,
                encoding: 'mapbox'
            },
            'dem': {
                type: 'raster-dem',
                encoding: 'terrarium',
                tiles: [demSource.sharedDemProtocolUrl],
                maxzoom: 14,
                tileSize: 512
            },
            'contours': {
                type: 'vector',
                tiles: [
                    demSource.contourProtocolUrl({
                        thresholds: {
                            11: [50, 200],
                            12: [50, 200],
                            13: [25, 100],
                            14: [25, 100],
                            15: [10, 50]
                        },
                        elevationKey: 'ele',
                        levelKey: 'level',
                        contourLayer: 'contours'
                    })
                ],
                maxzoom: 19
            },
            'buildings': {
                type: 'vector',
                tiles: [
                    'https://tiles.stadiamaps.com/data/openmaptiles/{z}/{x}/{y}.pbf'
                ],
                maxzoom: 14
            },
            'refuges': {
                type: 'geojson',
                data: {
                    type: 'FeatureCollection',
                    features: []
                }
            },
            'orthophotos': {
                type: 'raster',
                tiles: [
                    'https://wmts.geopf.fr/wmts?SERVICE=WMTS&REQUEST=GetTile&VERSION=1.0.0&LAYER=HR.ORTHOIMAGERY.ORTHOPHOTOS&' +
                    'TILEMATRIXSET=PM&TILEMATRIX={z}&TILEROW={y}&TILECOL={x}&FORMAT=image/jpeg&STYLE=normal'
                ],
                tileSize: 256,
                minzoom: 6,
                maxzoom: 19,
                attribution: '&copy; IGN/Geoportail'
            },
            'planIGN': {
                type: 'raster',
                tiles: [
                    'https://proxy.nakarte.me/https/heatmap-external-c.strava.com/tiles-auth/winter/hot/{z}/{x}/{y}.png?v=19&Key-Pair-Id=&Signature=&Policy='
                ],
                tileSize: 512,
                maxzoom: 18,
                attribution: '&copy; Data from Geoportail'
            },
            'sentinel2': {
                type: 'raster',
                tiles: [
                    `https://sh.dataspace.copernicus.eu/ogc/wms/db2d70bd-05c6-4ec3-9b31-f31a651821d5?` +
                    `SERVICE=WMS&VERSION=1.3.0&REQUEST=GetMap&FORMAT=image/png&TRANSPARENT=true&LAYERS=TRUE_COLOR&` +
                    `TILED=true&WIDTH=1024&HEIGHT=1024&CRS=EPSG:3857&BBOX={bbox-epsg-3857}`
                ],
                tileSize: 1024,
                maxzoom: 19,
                attribution: '&copy; <a href="https://www.copernicus.eu/en">Copernicus</a>'
            },
            'snowDepth': {
                type: 'raster',
                tiles: [
                    'https://p20.cosmos-project.ch/BfOlLXvmGpviW0YojaYiRqsT9NHEYdn88fpHZlr_map/gmaps/sd20alps@epsg3857/{z}/{x}/{y}.png'
                ],
                tileSize: 512,
                attribution: '&copy; Data from Exolab'
            },
            'tree-dem': {
                type: 'raster-dem',
                tiles: [
                    'https://earthengine.googleapis.com/v1/projects/earthengine-legacy/maps/3ce07bec7bce2b88566109c83f790de0-4175e542a166fa08d4c7ca8e4e2dd1e8/tiles/{z}/{x}/{y}'
                ],
                tileSize: 256,
                maxzoom: 19,
                encoding: 'mapbox',
                attribution: '&copy; <a href="https://research.facebook.com/blog/2023/4/every-tree-counts-large-scale-mapping-of-canopy-height-at-the-resolution-of-individual-trees/">Meta</a>'
            }
        },
        layers: [
            {
                id: 'baseColor',
                type: 'background',
                paint: {
                    'background-color': '#fff',
                    'background-opacity': 1.0,
                }
            },
            {
                id: 'contours',
                type: 'line',
                source: 'contours',
                'source-layer': 'contours',
                layout: { 
                    visibility: 'none',
                    'line-join': 'round'
                },
                paint: {
                    'line-color': 'rgba(0,0,0, 50%)',
                    'line-width': ['match', ['get', 'level'], 1, 1, 0.5]
                }
            },
            {
                id: 'contour-text',
                type: 'symbol',
                source: 'contours',
                'source-layer': 'contours',
                layout: {
                    visibility: 'none',
                    'symbol-placement': 'line',
                    'text-anchor': 'center',
                    'text-size': 10,
                    'text-field': ['concat', ['number-format', ['get', 'ele'], {}], 'm'],
                    'text-font': ['Noto Sans Regular']
                },
                paint: {
                    'text-halo-color': 'white',
                    'text-halo-width': 1
                },
                filter: ['>', ['get', 'level'], 0]
            },
            {
                id: 'sentinel2-layer',
                type: 'raster',
                source: 'sentinel2',
                minzoom: 6,
                maxzoom: 18,
                layout: { visibility: 'none' },
                paint: {
                    'raster-opacity': 0.8,
                    'raster-contrast': 0.1,
                    'raster-saturation': 0.1,
                    'raster-resampling': 'linear',
                    'raster-fade-duration': 300
                }
            },
            {
                id: 'Snow-layer',
                type: 'raster',
                source: 'snowDepth',
                minzoom: 0,
                maxzoom: 20,
                layout: { visibility: 'none' }
            },
            /*{
                id: 'tree-dem-hillshade',
                type: 'hillshade',
                source: 'tree-dem',
                layout: {visibility: 'visible'},
                paint: {
                    'hillshade-exaggeration': 0.1,
                    'hillshade-illumination-anchor': 'map',
                    'hillshade-illumination-direction': 280
                }
            },*/
            {
                id: 'hillshade-layer',
                type: 'hillshade',
                source: 'terrain-source',
                layout: {visibility: 'visible'},
                paint: {
                    'hillshade-exaggeration': 0.9,
                    'hillshade-illumination-anchor': 'map',
                    'hillshade-illumination-direction': 280
                }
            },
            {
                id: 'orthophotos-layer',
                type: 'raster',
                source: 'orthophotos',
                minzoom: 0,
                maxzoom: 19,
                layout: { visibility: 'visible' }
            },
            {
                id: 'planIGN-layer',
                type: 'raster',
                source: 'planIGN',
                minzoom: 0,
                maxzoom: 18,
                layout: { visibility: 'none' }
            },
            {
                'id': '3d-buildings',
                'source': 'buildings',
                'source-layer': 'building',
                'type': 'fill-extrusion',
                'minzoom': 14,
                'filter': ['!=', ['get', 'hide_3d'], true],
                'paint': {
                    'fill-extrusion-color': '#F5F5DC',  // Beige color
                    'fill-extrusion-height': [
                        'interpolate',
                        ['linear'],
                        ['zoom'],
                        15, 0,
                        16, ['get', 'render_height']
                    ],
                    'fill-extrusion-base': ['get', 'render_min_height'],
                    'fill-extrusion-opacity': 0.9
                }
            }, 
            {
                id: 'refuges-layer',
                type: 'symbol',
                source: 'refuges',
                layout: {
                    // Icon settings
                    'icon-image': ['case',
                        ['has', 'photo'], ['get', 'photo'], // Use photo from API if available
                        'refuge' // Fallback to default icon
                    ],
                    'icon-size': 1,
                    'icon-allow-overlap': true,
                    
                    // Text settings
                    'text-field': ['get', 'nom'],
                    'text-font': ['Noto Sans Regular'],
                    'text-offset': [0, 1],
                    'text-anchor': 'top',
                    'text-size': 14,
                    
                    // Place text below icon
                    'text-variable-anchor': ['bottom'],
                    'text-radial-offset': 1,
                    
                    // Improve icon clustering
                    'icon-padding': 5,
                    'text-padding': 5
                },
                paint: {
                    'text-color': '#000',
                    'text-halo-color': '#fff',
                    'text-halo-width': 2
                }
            }
        ],
        terrain:
        {
            source: 'terrain-source',
            exaggeration: 1.0
        },

        /*{
            source: 'tree-dem',
            exaggeration: 0.00002
        },*/

        sky: {
            "sky-color": "#199EF3",
            "sky-horizon-blend": 0.5,
            "horizon-color": "#ffffff",
            "horizon-fog-blend": 0.5,
            "fog-color": "#888888",
            "fog-ground-blend": 0.5,
            "atmosphere-blend": [
                "interpolate",
                ["linear"],
                ["zoom"],
                0, 1, 10, 1, 12, 0
            ]
        }
    },
    center: [5.7245, 45.1885],
    zoom: 14,
    pitch: 70,
    hash: true,
    antialias: true,
    cancelPendingTileRequestsWhileZooming: true,
    maxZoom: 20,
    maxPitch: 70,
    fadeDuration: 2000
});

map.addControl(
    new maplibregl.TerrainControl({
        source: 'terrainSource',
        exaggeration: 0.1
    })
);

// Constants
const THROTTLE_DELAY = 500;
const photoCache = new Map();
const processedFeatures = new Set();

// Utility Functions
function throttle(func, limit) {
    let inThrottle;
    return function(...args) {
        if (!inThrottle) {
            func.apply(this, args);
            inThrottle = true;
            setTimeout(() => inThrottle = false, limit);
        }
    }
}
function getDistanceFromLatLonInM(lat1, lon1, lat2, lon2) {
    const R = 6371e3;
    const œÜ1 = lat1 * Math.PI/180;
    const œÜ2 = lat2 * Math.PI/180;
    const ŒîœÜ = (lat2-lat1) * Math.PI/180;
    const ŒîŒª = (lon2-lon1) * Math.PI/180;

    const a = Math.sin(ŒîœÜ/2) * Math.sin(ŒîœÜ/2) +
            Math.cos(œÜ1) * Math.cos(œÜ2) *
            Math.sin(ŒîŒª/2) * Math.sin(ŒîŒª/2);
    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));

    return R * c;
}
function calculateOptimizedBbox(bounds, center, currentZoom) {
    const padding = Math.max(0.1, 0.3 - (currentZoom * 0.01));
    const latSpan = bounds.getNorth() - bounds.getSouth();
    const lngSpan = bounds.getEast() - bounds.getWest();
    
    if (currentZoom > 14) {
        const bearing = map.getBearing();
        const viewFactor = 1.5;
        const northPadding = bearing > 180 ? padding * viewFactor : padding;
        const southPadding = bearing < 180 ? padding * viewFactor : padding;
        const eastPadding = bearing < 90 || bearing > 270 ? padding * viewFactor : padding;
        const westPadding = bearing > 90 && bearing < 270 ? padding * viewFactor : padding;
        
        return `${
            bounds.getWest() - (lngSpan * westPadding)
        },${
            bounds.getSouth() - (latSpan * southPadding)
        },${
            bounds.getEast() + (lngSpan * eastPadding)
        },${
            bounds.getNorth() + (latSpan * northPadding)
        }`;
    }
    
    return `${
        bounds.getWest() - (lngSpan * padding)
    },${
        bounds.getSouth() - (latSpan * padding)
    },${
        bounds.getEast() + (lngSpan * padding)
    },${
        bounds.getNorth() + (latSpan * padding)
    }`;
}
function formatPopupContent(properties) {
    console.log('[DEBUG] Formatting popup with properties:', properties);
    let p = properties;
    
    const parseJsonProp = (prop) => {
        if (typeof prop === 'string' && prop.startsWith('{')) {
            try {
                return JSON.parse(prop);
            } catch (e) {
                return prop;
            }
        }
        return prop;
    };

    // Parse JSON strings
    p.coord = parseJsonProp(p.coord);
    p.places = parseJsonProp(p.places);
    p.proprio = parseJsonProp(p.proprio);
    p.info_comp = parseJsonProp(p.info_comp);
    p.remarque = parseJsonProp(p.remarque);
    p.acces = parseJsonProp(p.acces);
    p.type = parseJsonProp(p.type);
    p.date = parseJsonProp(p.date);

    console.log('[DEBUG] Raw PhotoUrls:', p.photoUrls);
    
    // Create carousel HTML
    let carouselHtml = '';
    if (p.photoUrls && p.photoUrls.length > 0) {
        const uniquePhotos = [...new Set(p.photoUrls)];
        console.log('[DEBUG] Processing unique photos:', uniquePhotos);

        carouselHtml = `
            <div class="carousel-container" style="margin-bottom: 15px; position: relative;">
                <div class="carousel-slides" style="position: relative; min-height: 200px;">
                    ${uniquePhotos.map((url, index) => {
                        const fullUrl = `https://www.refuges.info${url}`;
                        console.log('[DEBUG] Creating slide with URL:', fullUrl);
                        
                        return `
                            <div class="carousel-slide ${index === 0 ? 'active' : ''}" 
                                 data-index="${index}" 
                                 style="display: ${index === 0 ? 'block' : 'none'}; position: absolute; width: 100%;">
                                <img src="${fullUrl}" 
                                     alt="${p.nom} - Photo ${index + 1}" 
                                     style="width: 100%; height: 200px; object-fit: cover; border-radius: 4px;">
                            </div>
                        `;
                    }).join('')}
                </div>
                ${uniquePhotos.length > 1 ? `
                    <div class="carousel-controls" style="position: absolute; bottom: 10px; left: 0; right: 0; display: flex; justify-content: center; gap: 10px; z-index: 10;">
                        <button class="carousel-button" onclick="changeSlide(this, -1)" 
                                style="background: rgba(255,255,255,0.8); border: none; border-radius: 50%; width: 30px; height: 30px; cursor: pointer; display: flex; align-items: center; justify-content: center;">‚ùÆ</button>
                        <span class="carousel-counter" style="background: rgba(255,255,255,0.8); padding: 4px 8px; border-radius: 12px;">1/${uniquePhotos.length}</span>
                        <button class="carousel-button" onclick="changeSlide(this, 1)"
                                style="background: rgba(255,255,255,0.8); border: none; border-radius: 50%; width: 30px; height: 30px; cursor: pointer; display: flex; align-items: center; justify-content: center;">‚ùØ</button>
                    </div>
                ` : ''}
            </div>
        `;
    }

    return `
        <div class="refuge-popup">
            <h3 style="margin: 0 0 15px 0; color: #2d4059; border-bottom: 2px solid #2d4059; padding-bottom: 5px;">
                ${p.nom}
            </h3>
            ${carouselHtml}
            <div style="display: grid; grid-template-columns: auto 1fr; gap: 10px; margin-bottom: 15px;">
                <div style="font-weight: bold;">Altitude:</div>
                <div>${p.coord.alt}m</div>
                <div style="font-weight: bold;">Capacit√©:</div>
                <div>${p.places.valeur} places</div>
                <div style="font-weight: bold;">Propri√©taire:</div>
                <div>${p.proprio.valeur}</div>
            </div>
            <div style="margin: 15px 0; padding: 10px; background: #f5f5f5; border-radius: 4px;">
                <div style="font-weight: bold; margin-bottom: 8px;">√âquipements:</div>
                <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 5px;">
                    ${p.info_comp.eau.valeur === "1" ? '<div>üíß Eau √† proximit√©</div>' : ''}
                    ${p.info_comp.bois.valeur === "1" ? '<div>üå≥ For√™t √† proximit√©</div>' : ''}
                    ${p.info_comp.poele.valeur === "1" ? '<div>üî• Po√™le</div>' : ''}
                    ${p.info_comp.latrines.valeur === "1" ? '<div>üöΩ Latrines</div>' : ''}
                    ${p.info_comp.cheminee.valeur === "1" ? '<div>üè† Chemin√©e</div>' : ''}
                    ${p.info_comp.couvertures.valeur === "1" ? '<div>üõèÔ∏è Couvertures</div>' : ''}
                </div>
            </div>
            <div style="margin-top: 15px; font-size: 0.9em; color: #666;">
                <div>Type: ${p.type.valeur}</div>
                <div style="word-break: break-all; margin-top: 10px;">
                    <a href="${p.lien}" target="_blank">${p.lien}</a>
                </div>
            </div>
        </div>
    `;
}
async function getPointPhotos(feature) {
    try {
        const pageUrl = feature.properties.lien;
        const proxyUrl = `https://api.allorigins.win/raw?url=${encodeURIComponent(pageUrl)}`;
        console.log(`[DEBUG] Fetching photos from: ${pageUrl}`);
        
        const response = await fetch(proxyUrl);
        if (!response.ok) {
            console.warn(`Failed to fetch page for point ${feature.properties.id}:`, response.status);
            return null;
        }

        const html = await response.text();
        const parser = new DOMParser();
        const doc = parser.parseFromString(html, 'text/html');
        
        const photoRegex = /photos_points\/\d+-reduite\.jpeg/;
        const images = Array.from(doc.querySelectorAll('img'))
            .map(img => img.src)
            .filter(src => photoRegex.test(src))
            .map(src => src.replace(/^https?:\/\/[^/]+/, ''));

        console.log(`[DEBUG] Found ${images.length} photos for point ${feature.properties.id}:`, images);
        return images;
        
    } catch (error) {
        console.warn(`Error getting photo for point ${feature.properties.id}:`, error);
        return null;
    }
}
async function createPointPopup(coordinates, properties) {
    const photoId = `photo-${properties.id}`;
    if (photoCache.has(photoId) && !properties.photoUrls) {
        properties.photoUrls = photoCache.get(photoId);
    }

    if (!properties.photoUrls) {
        properties.photoUrls = await getPointPhotos({ properties });
    }

    const popupContent = formatPopupContent(properties);

    new maplibregl.Popup()
        .setLngLat(coordinates)
        .setHTML(popupContent)
        .addTo(map);
}
async function fetchPointsOfInterest() {
    const currentZoom = map.getZoom();
    if (currentZoom < 11) {
        map.getSource('refuges').setData({
            type: 'FeatureCollection',
            features: []
        });
        return;
    }

    try {
        const bounds = map.getBounds();
        const center = map.getCenter();
        const bbox = calculateOptimizedBbox(bounds, center, currentZoom);

        const response = await fetch(
            `https://www.refuges.info/api/bbox?bbox=${bbox}&type_points=cabane,refuge,gite,pt_eau,sommet,pt_passage,bivouac,lac&format=geojson&detail=complet`
        );
        if (!response.ok) throw new Error('Network response was not ok');
        const data = await response.json();

        const featuresWithDistance = data.features.map(feature => ({
            feature,
            distance: getDistanceFromLatLonInM(
                center.lat,
                center.lng,
                feature.geometry.coordinates[1],
                feature.geometry.coordinates[0]
            )
        }));

        featuresWithDistance.sort((a, b) => a.distance - b.distance);

        featuresWithDistance.forEach(({ feature }) => {
            const photoId = `photo-${feature.properties.id}`;
            if (photoCache.has(photoId)) {
                feature.properties.photoId = photoId;
            }
        });

        data.features = featuresWithDistance.map(f => f.feature);
        if (map.getSource('refuges')) {
            map.getSource('refuges').setData(data);
        }

        const BATCH_SIZE = 3;
        const unprocessedFeatures = featuresWithDistance.filter(
            ({ feature }) => !processedFeatures.has(feature.properties.id)
        );

        for (let i = 0; i < unprocessedFeatures.length; i += BATCH_SIZE) {
            const batch = unprocessedFeatures.slice(i, i + BATCH_SIZE);
            await Promise.all(batch.map(async ({ feature }) => {
                const photoId = `photo-${feature.properties.id}`;
                
                if (processedFeatures.has(feature.properties.id)) return;

                try {
                    const photoUrls = await getPointPhotos(feature);
                    if (photoUrls && photoUrls.length > 0) {
                        feature.properties.photoUrls = photoUrls;
                        
                        if (!map.hasImage(photoId)) {
                            const photoUrl = `https://www.refuges.info${photoUrls[0]}`;
                            const proxyUrl = `https://api.allorigins.win/raw?url=${encodeURIComponent(photoUrl)}`;
                            const photoResponse = await fetch(proxyUrl);
                            if (!photoResponse.ok) return;

                            const photoBlob = await photoResponse.blob();
                            const imageBitmap = await createImageBitmap(photoBlob);

                            const size = 128;
                            const canvas = document.createElement('canvas');
                            canvas.width = size;
                            canvas.height = size;
                            const ctx = canvas.getContext('2d');

                            // Determine color based on type
                            const type = feature.properties.type.valeur;
                            let typeColor;
                            if (type.includes("point d'eau")) {
                                typeColor = '#558e5b';
                            } else if (type.includes('sommet') || type.includes('passage')) {
                                typeColor = '#ff4444';
                            } else if (type.includes('refuge') || type.includes('cabane') || type.includes('g√Æte')) {
                                typeColor = '#ffffff';
                            } else if (type.includes('lac')) {
                                typeColor = '#4682B4';
                            } else if (type.includes('bivouac')) {
                                typeColor = '#f5a442';
                            } else {
                                typeColor = '#f5a442';
                            }

                            ctx.beginPath();
                            ctx.arc(size/2, size/2, size/2, 0, Math.PI * 2);
                            ctx.fillStyle = 'white';
                            ctx.fill();

                            ctx.save();
                            ctx.beginPath();
                            ctx.arc(size/2, size/2, size/2 - 4, 0, Math.PI * 2);
                            ctx.clip();
                            ctx.drawImage(imageBitmap, 0, 0, size, size);
                            ctx.restore();

                            ctx.beginPath();
                            ctx.arc(size/2, size/2, size/2 - 2, 0, Math.PI * 2);
                            ctx.strokeStyle = typeColor;
                            ctx.lineWidth = 4;
                            ctx.stroke();

                            const imageData = ctx.getImageData(0, 0, size, size);
                            map.addImage(photoId, imageData);
                        }

                        feature.properties.photoId = photoId;
                        photoCache.set(photoId, photoUrls);
                        processedFeatures.add(feature.properties.id);

                        const currentData = map.getSource('refuges')._data;
                        const index = currentData.features.findIndex(f => 
                            f.properties.id === feature.properties.id
                        );
                        if (index !== -1) {
                            currentData.features[index] = feature;
                            map.getSource('refuges').setData(currentData);
                        }
                    }
                } catch (error) {
                    console.warn(`Failed to process photos for point ${feature.properties.id}:`, error);
                }
            }));
        }

        data.features.forEach(feature => {
            feature.properties.onClick = () => {
                const coordinates = feature.geometry.coordinates.slice();
                const properties = feature.properties;
                createPointPopup(coordinates, properties);
            };
        });

    } catch (error) {
        console.error('Error fetching points of interest:', error);
    }
}
window.changeSlide = function(button, direction) {
    const container = button.closest('.carousel-container');
    const slides = container.querySelectorAll('.carousel-slide');
    const counter = container.querySelector('.carousel-counter');
    
    let currentIndex = Array.from(slides).findIndex(slide => 
        slide.classList.contains('active')
    );
    
    slides[currentIndex].classList.remove('active');
    slides[currentIndex].style.display = 'none';
    
    currentIndex = (currentIndex + direction + slides.length) % slides.length;
    
    slides[currentIndex].classList.add('active');
    slides[currentIndex].style.display = 'block';
    
    counter.textContent = `${currentIndex + 1}/${slides.length}`;
    
    const prevIndex = (currentIndex - 1 + slides.length) % slides.length;
    const nextIndex = (currentIndex + 1) % slides.length;
    slides[prevIndex].querySelector('img').setAttribute('loading', 'lazy');
    slides[nextIndex].querySelector('img').setAttribute('loading', 'lazy');
};
function getDistanceFromLatLonInKm(lat1, lon1, lat2, lon2) {
    const R = 6371; // Radius of the earth in km
    const dLat = deg2rad(lat2 - lat1);
    const dLon = deg2rad(lon2 - lon1);
    const a = 
        Math.sin(dLat/2) * Math.sin(dLat/2) +
        Math.cos(deg2rad(lat1)) * Math.cos(deg2rad(lat2)) * 
        Math.sin(dLon/2) * Math.sin(dLon/2);
    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
    return R * c; // Distance in km
}
function deg2rad(deg) {
    return deg * (Math.PI/180);
}
// =====================
// Configuration Constants with Debug Logging
// =====================

const CONFIG = {
    PATH_SEARCH_RADIUS: 0.05,      // 50m
    NODE_CONNECTION_TOLERANCE: 0.01, // 10m
    MAX_ROUTE_DISTANCE: 10.0,        // 10km
    CORRIDOR_BUFFER_DISTANCE: 0.03,  // 20m
    POI_SEARCH_BUFFER: 0.03,        // 20m
    DUPLICATE_POI_THRESHOLD: 0.05,
    INITIAL_SEARCH_AREA_RADIUS: 0.01,
    MIN_POI_DISTANCE: 0.1, // 100 meters minimum distance from signpost
    EDGES_PER_DIRECTION: 3,        // Number of initial edges to consider per direction
    MIN_SEGMENT_LENGTH: 0.01       // Minimum segment length to consider (10m)
};

const DEBUG = {
    enabled: true,
    logConfig: function() {
        if (!this.enabled) return;
        console.log('Current Configuration:', {
            ...CONFIG,
            PATH_SEARCH_RADIUS_METERS: CONFIG.PATH_SEARCH_RADIUS * 1000,
            NODE_CONNECTION_TOLERANCE_METERS: CONFIG.NODE_CONNECTION_TOLERANCE * 1000,
            CORRIDOR_BUFFER_DISTANCE_METERS: CONFIG.CORRIDOR_BUFFER_DISTANCE * 1000
        });
    },
    logNetwork: function(network) {
        if (!this.enabled) return;
        console.log('Network Statistics:', {
            nodes: network.nodes.length,
            edges: network.edges.length,
            averageEdgeLength: network.edges.reduce((sum, edge) => 
                sum + turf.length(turf.lineString(edge.coords), { units: 'kilometers' }), 0) / network.edges.length
        });
    },
    logRoute: function(route, index) {
        if (!this.enabled) return;
        const length = turf.length(turf.lineString(route), { units: 'kilometers' });
        console.log(`Route ${index}: ${length.toFixed(2)}km, ${route.length} points`);
    }
};

// =====================
// Utility Functions
// =====================

function calculateHikingTime(distance, elevationGain, difficulty) {
    if (DEBUG.enabled) {
        console.log('Calculating hiking time:', { distance, elevationGain, difficulty });
    }
    const baseSpeed = 4.5;
    const slope = distance > 0 ? elevationGain / (distance * 1000) : 0;
    const speedFactor = Math.exp(-3.5 * Math.abs(slope + 0.05));
    const difficultyFactors = {
        'hiking': 1.0,
        'mountain_hiking': 0.85,
        'demanding_mountain_hiking': 0.7,
        'alpine_hiking': 0.6,
        'demanding_alpine_hiking': 0.5,
        'difficult_alpine_hiking': 0.4,
        'road': 1.0
    };
    const difficultyFactor = difficultyFactors[difficulty] || 1.0;
    const speed = baseSpeed * speedFactor * difficultyFactor;
    const timeHours = distance / (speed || 1);
    const elevationTime = elevationGain / 600;
    const totalTime = timeHours + elevationTime;
    const hours = Math.floor(totalTime);
    const minutes = Math.round((totalTime - hours) * 60);
    return `${hours}h${minutes.toString().padStart(2, '0')}`;
}

// Constants for direction calculation
const DIRECTION_CALC = {
    SAMPLE_POINTS: 5,          // Number of points to sample along initial path
    SAMPLE_DISTANCE: 0.1,      // Distance between sample points in km
    BEARING_WEIGHT: 0.6        // Weight for initial bearing vs average bearing
};

function getCardinalDirection(bearing) {
    // Normalize bearing to 0-360
    bearing = (bearing + 360) % 360;
    
    // Define direction ranges with 45¬∞ segments centered on cardinal/intercardinal directions
    if (bearing >= 337.5 || bearing < 22.5) return '‚Üë N';
    if (bearing >= 22.5 && bearing < 67.5) return '‚Üó NE';
    if (bearing >= 67.5 && bearing < 112.5) return '‚Üí E';
    if (bearing >= 112.5 && bearing < 157.5) return '‚Üò SE';
    if (bearing >= 157.5 && bearing < 202.5) return '‚Üì S';
    if (bearing >= 202.5 && bearing < 247.5) return '‚Üô SW';
    if (bearing >= 247.5 && bearing < 292.5) return '‚Üê W';
    if (bearing >= 292.5 && bearing < 337.5) return '‚Üñ NW';
    return '‚Üë N';
}

function calculatePathDirection(startPoint, coords) {
    if (coords.length < 2) return null;
    
    // Take a point sufficiently far along the path (50m or 0.05km)
    const pathLine = turf.lineString(coords);
    const pathLength = turf.length(pathLine, { units: 'kilometers' });
    const sampleDistance = Math.min(0.05, pathLength / 2);
    
    const pointAhead = turf.along(pathLine, sampleDistance, { units: 'kilometers' });
    
    const bearing = turf.bearing(
        turf.point([startPoint.lng, startPoint.lat]),
        pointAhead
    );
    
    return getCardinalDirection(bearing);
}

function validateDirectionCalculation(startPoint, coords, direction) {
    if (DEBUG.enabled) {
        const line = turf.lineString(coords);
        const length = turf.length(line, { units: 'kilometers' });
        const endPoint = turf.point(coords[coords.length - 1]);
        const straightBearing = turf.bearing(
            turf.point([startPoint.lng, startPoint.lat]),
            endPoint
        );

        console.log('Direction validation:', {
            calculatedDirection: direction,
            straightLineBearing: getCardinalDirection(straightBearing),
            pathLength: length,
            pointCount: coords.length
        });
    }
}


function insertSignpostNode(lineFeatures, signpostPoint) {
    let closestFeature = null;
    let minDist = Infinity;
    
    for (const f of lineFeatures) {
        if (!f.geometry || f.geometry.type !== 'LineString') continue;
        const line = turf.lineString(f.geometry.coordinates);
        const nearest = turf.nearestPointOnLine(line, turf.point([signpostPoint.lng, signpostPoint.lat]));
        const dist = nearest.properties.dist;
        if (dist < minDist) {
            minDist = dist;
            closestFeature = f;
        }
    }

    if (!closestFeature) {
        if (DEBUG.enabled) {
            console.warn('No closest line found for signpost');
        }
        return lineFeatures;
    }

    const line = turf.lineString(closestFeature.geometry.coordinates);
    const nearest = turf.nearestPointOnLine(line, turf.point([signpostPoint.lng, signpostPoint.lat]));
    const location = nearest.properties.location;
    const lineLength = turf.length(line, { units: 'kilometers' });

    if (location > 0 && location < lineLength) {
        const part1 = turf.lineSliceAlong(line, 0, location, { units: 'kilometers' });
        const part2 = turf.lineSliceAlong(line, location, lineLength, { units: 'kilometers' });
        part1.properties = { ...closestFeature.properties };
        part2.properties = { ...closestFeature.properties };

        const index = lineFeatures.indexOf(closestFeature);
        if (index !== -1) {
            lineFeatures.splice(index, 1, part1, part2);
        }
    }

    return lineFeatures;
}

function findOrCreateNode(nodes, coord) {
    const coordPoint = turf.point(coord);
    let closestNodeIndex = null;
    let minDist = Infinity;

    for (let i = 0; i < nodes.length; i++) {
        const dist = turf.distance(coordPoint, turf.point(nodes[i]), { units: 'kilometers' });
        if (dist < CONFIG.NODE_CONNECTION_TOLERANCE && dist < minDist) {
            minDist = dist;
            closestNodeIndex = i;
        }
    }

    if (closestNodeIndex !== null) {
        if (DEBUG.enabled) {
            console.log(`Reusing existing node ${closestNodeIndex} at distance ${minDist.toFixed(5)}km`);
        }
        return closestNodeIndex;
    } else {
        const newIndex = nodes.length;
        nodes.push(coord);
        if (DEBUG.enabled) {
            console.log(`Created new node ${newIndex} at [${coord}]`);
        }
        return newIndex;
    }
}

function findClosestNode(point, nodes) {
    let closestNode = null;
    let minDist = Infinity;
    
    for (let i = 0; i < nodes.length; i++) {
        const dist = turf.distance(point, turf.point(nodes[i]), { units: 'kilometers' });
        if (dist < minDist) {
            minDist = dist;
            closestNode = i;
        }
    }
    
    if (DEBUG.enabled && closestNode !== null) {
        console.log(`Found closest node: ${closestNode} at distance: ${minDist.toFixed(3)}km`);
    }
    
    return closestNode;
}

function orientEdgeAtNode(network, edge, fromNode) {
    let lineCoords = edge.coords;
    const fromNodeCoord = network.nodes[fromNode];
    if (!coordsEqual(fromNodeCoord, lineCoords[0])) {
        lineCoords = [...lineCoords].reverse();
    }
    return lineCoords;
}

function sliceFromSignpost(signpostPoint, lineCoords) {
    const fullLine = turf.lineString(lineCoords);
    const nearest = turf.nearestPointOnLine(fullLine, turf.point([signpostPoint.lng, signpostPoint.lat]));
    if (nearest.properties.location > 0) {
        const sliced = turf.lineSlice(nearest, turf.point(lineCoords[lineCoords.length - 1]), fullLine);
        return sliced.geometry.coordinates;
    }
    return lineCoords;
}

function createSignpostPopup(results, signpostLabel, signpostElevation) {
    if (!results || results.length === 0) {
        return `
            <div class="signpost-popup" style="padding: 10px;">
                <div style="color: #666;">No destinations found nearby</div>
            </div>
        `;
    }

    const content = results.map(direction => `
        <div class="signpost-direction" style="
            margin-bottom: 5px;
            background: #FFD700;
            padding: 5px;
            border-radius: 4px;
        ">
            <!-- Arrow + Cardinal Direction -->
            <div style="display: flex; align-items: center; font-weight: bold; margin-bottom: 5px;">
                <div style="margin-right: 8px; font-size: 16px;">&#x27A4;</div>
                <div>${direction.direction}</div>
            </div>

            <!-- POI List -->
            ${direction.destinations.map(dest => `
                <div class="destination" style="
                    display: flex;
                    justify-content: space-between;
                    align-items: center;
                    margin-bottom: 5px;
                    font-size: 12px;
                    color: #333;
                ">
                    <!-- POI Name -->
                    <div style="font-weight: bold; flex: 1;">
                        <span style="margin-right: 30px;">${dest.name}</span>
                    </div>
                    <!-- Distance and Duration -->
                    <div style="
                        display: flex;
                        gap: 10px;
                        white-space: nowrap; /* Ensures no line breaks */
                    ">
                        <span>${dest.distance.toFixed(1)} km</span>
                        <span>${dest.time}</span>
                    </div>
                </div>
            `).join('')}
        </div>
    `).join('');

    return `
        <div class="signpost-popup" style="
            padding: 10px;
            max-width: 500px;
            background: #fff;
            border-radius: 4px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            font-family: Arial, sans-serif;
        ">
            <!-- Square Header -->
            <div style="
                background: #4CAF50;
                color: #fff;
                height: 80px;
                width: 80px;
                margin: 0 auto 10px;
                display: flex;
                flex-direction: column;
                justify-content: center;
                align-items: center;
                border-radius: 4px;
                box-shadow: 0 2px 4px rgba(0,0,0,0.2);
                font-size: 12px;
                font-weight: bold;
            ">
                <div style="font-weight: bold; font-size: 12px;">${signpostLabel || 'Signpost'}</div>
                <div>${signpostElevation ? `${signpostElevation}m` : 'N/A'}</div>
            </div>
            ${content}
        </div>
    `;
}

function coordsEqual(a, b) {
    return Math.abs(a[0] - b[0]) < 1e-7 && Math.abs(a[1] - b[1]) < 1e-7;
}

function combineCoords(a, b) {
    if (DEBUG.enabled) {
        console.log('Combining coordinates:', {
            aLength: a.length,
            bLength: b.length,
            endpointsMatch: coordsEqual(a[a.length - 1], b[0])
        });
    }
    if (coordsEqual(a[a.length - 1], b[0])) {
        return a.concat(b.slice(1));
    } else {
        return a.concat(b);
    }
}

// =====================
// Network Building with Debug Info
// =====================
function findOrCreateNodeWithFusion(nodes, coord, edges) {
    const coordPoint = turf.point(coord);
    let closestNodeIndex = null;
    let minDist = Infinity;

    // First check existing nodes
    for (let i = 0; i < nodes.length; i++) {
        const dist = turf.distance(coordPoint, turf.point(nodes[i]), { units: 'kilometers' });
        if (dist < CONFIG.NODE_CONNECTION_TOLERANCE && dist < minDist) {
            minDist = dist;
            closestNodeIndex = i;
        }
    }

    // If no existing node found, check for nearby path segments
    if (closestNodeIndex === null) {
        for (let edgeIndex = 0; edgeIndex < edges.length; edgeIndex++) {
            const edge = edges[edgeIndex];
            
            // Skip invalid edges
            if (!edge.coords || edge.coords.length < 2) continue;

            try {
                const line = turf.lineString(edge.coords);
                const nearest = turf.nearestPointOnLine(line, coordPoint);
                const dist = nearest.properties.dist;

                if (dist < CONFIG.NODE_CONNECTION_TOLERANCE && dist < minDist) {
                    // Found a path to split
                    const splitPoint = nearest.geometry.coordinates;
                    minDist = dist;
                    
                    // Create new node at split point
                    closestNodeIndex = nodes.length;
                    nodes.push(splitPoint);

                    if (DEBUG.enabled) {
                        console.log(`Creating fusion node ${closestNodeIndex} at dist ${dist.toFixed(5)}km from path`);
                    }

                    // Split the existing edge only if we have valid index
                    const splitIndex = nearest.properties.index;
                    if (splitIndex >= 0 && splitIndex < edge.coords.length - 1) {
                        const coords1 = edge.coords.slice(0, splitIndex + 1).concat([splitPoint]);
                        const coords2 = [splitPoint].concat(edge.coords.slice(splitIndex + 1));

                        // Verify both parts are valid before splitting
                        if (coords1.length >= 2 && coords2.length >= 2) {
                            // Replace original edge with split edges
                            edges.splice(edgeIndex, 1, {
                                coords: coords1,
                                difficulty: edge.difficulty
                            }, {
                                coords: coords2,
                                difficulty: edge.difficulty
                            });
                            if (DEBUG.enabled) {
                                console.log(`Split edge at node ${closestNodeIndex}, creating segments of ${coords1.length} and ${coords2.length} points`);
                            }
                        }
                    }
                    break;  // Found our split point
                }
            } catch (error) {
                if (DEBUG.enabled) {
                    console.warn('Error processing edge:', error);
                }
                continue;
            }
        }
    }

    if (closestNodeIndex !== null) {
        return closestNodeIndex;
    }

    const newIndex = nodes.length;
    nodes.push(coord);
    return newIndex;
}

function buildPathNetwork(lineFeatures) {
    if (DEBUG.enabled) {
        console.log('Building network from features:', lineFeatures.length);
    }

    const nodes = [];
    const edges = [];
    const debugInfo = {
        skippedFeatures: 0,
        shortLines: 0,
        addedEdges: 0,
        fusedNodes: 0
    };

    // First pass: create initial edges
    for (const f of lineFeatures) {
        if (!f.geometry || f.geometry.type !== 'LineString') {
            debugInfo.skippedFeatures++;
            continue;
        }
        const coords = f.geometry.coordinates;
        if (coords.length < 2) {
            debugInfo.shortLines++;
            continue;
        }

        edges.push({
            coords: coords,
            difficulty: f.properties.sac_scale || 'road'
        });
        debugInfo.addedEdges++;
    }

    // Second pass: build nodes with fusion
    const networkEdges = [];
    for (const edge of edges) {
        const startNode = findOrCreateNodeWithFusion(nodes, edge.coords[0], edges);
        const endNode = findOrCreateNodeWithFusion(nodes, edge.coords[edge.coords.length - 1], edges);

        networkEdges.push({
            start: startNode,
            end: endNode,
            coords: edge.coords,
            difficulty: edge.difficulty
        });
    }

    function deduplicateEdges(edges) {
        const seen = new Set();
        return edges.filter(edge => {
            const key = `${edge.start}-${edge.end}-${edge.coords[0][0]}-${edge.coords[0][1]}`;
            if (seen.has(key)) return false;
            seen.add(key);
            return true;
        });
    }

    // Build adjacency list
    const adjacency = new Map();
    for (let i = 0; i < nodes.length; i++) {
        adjacency.set(i, []);
    }

    for (const e of networkEdges) {
        const length = turf.length(turf.lineString(e.coords), { units: 'kilometers' });

        adjacency.get(e.start).push({
            start: e.start,
            end: e.end,
            coords: e.coords,
            difficulty: e.difficulty,
            length: length
        });

        adjacency.get(e.end).push({
            start: e.end,
            end: e.start,
            coords: [...e.coords].reverse(),
            difficulty: e.difficulty,
            length: length
        });
    }

    if (DEBUG.enabled) {
        console.log('Network building statistics:', {
            ...debugInfo,
            finalNodes: nodes.length,
            finalEdges: networkEdges.length
        });
    }

    return { nodes, edges: networkEdges, adjacency, debugInfo };
}

// =====================
// Route Building with Debug Visualization
// =====================

function buildRoutesFromSignpost(network, startNode, signpostPoint) {
    const routes = [];
    const visitedEdges = new Set();  // Track visited edges instead of nodes
    const queue = [];
    const terminationPoints = [];
    const debugInfo = {
        totalRoutes: 0,
        truncatedRoutes: 0,
        maxRouteLength: 0,
        minRouteLength: Infinity,
        processedEdges: 0,
        directionsFound: 0,
        terminationReasons: {
            max_distance: 0,
            cycle: 0,
            no_advance: 0
        }
    };

    // Get initial edges and sort them by direction
    const initialEdges = network.adjacency.get(startNode) || [];
    const edgesByDirection = new Map();
    
    if (DEBUG.enabled) {
        console.log(`Starting from node ${startNode} with ${initialEdges.length} initial edges`);
    }
    
    // Group initial edges by direction
    initialEdges.forEach(edge => {
        const direction = calculatePathDirection(signpostPoint, edge.coords);
        
        if (!edgesByDirection.has(direction)) {
            edgesByDirection.set(direction, []);
            debugInfo.directionsFound++;
        }
        edgesByDirection.get(direction).push(edge);
    });

    // Take edges per direction
    const limitedInitialEdges = [];
    edgesByDirection.forEach((edges, direction) => {
        const sortedEdges = edges.sort((a, b) => {
            const lengthA = turf.length(turf.lineString(a.coords), { units: 'kilometers' });
            const lengthB = turf.length(turf.lineString(b.coords), { units: 'kilometers' });
            return lengthA - lengthB;
        });
        limitedInitialEdges.push(...sortedEdges.slice(0, CONFIG.EDGES_PER_DIRECTION));
    });

    // Process initial edges
    for (const e of limitedInitialEdges) {
        let lineCoords = orientEdgeAtNode(network, e, startNode);
        lineCoords = sliceFromSignpost(signpostPoint, lineCoords);
        const dist = turf.length(turf.lineString(lineCoords), { units: 'kilometers' });
        const edgeKey = `${Math.min(e.start, e.end)}-${Math.max(e.start, e.end)}`;
        
        debugInfo.processedEdges++;
        visitedEdges.add(edgeKey);

        if (dist > CONFIG.MAX_ROUTE_DISTANCE) {
            const partial = turf.lineSliceAlong(
                turf.lineString(lineCoords),
                0,
                CONFIG.MAX_ROUTE_DISTANCE,
                { units: 'kilometers' }
            );
            routes.push(partial.geometry.coordinates);
            debugInfo.truncatedRoutes++;
            debugInfo.totalRoutes++;
            debugInfo.maxRouteLength = Math.max(debugInfo.maxRouteLength, CONFIG.MAX_ROUTE_DISTANCE);
            debugInfo.minRouteLength = Math.min(debugInfo.minRouteLength, CONFIG.MAX_ROUTE_DISTANCE);
            
            terminationPoints.push({
                coords: partial.geometry.coordinates[partial.geometry.coordinates.length - 1],
                reason: 'max_distance',
                details: `${dist.toFixed(2)}km`
            });
            continue;
        }

        queue.push({
            currentNode: e.end,
            coords: lineCoords,
            distance: dist,
            previousNode: startNode,
            path: [startNode, e.end],
            direction: calculatePathDirection(signpostPoint, lineCoords)
        });
    }

    // Process the queue
    while (queue.length > 0) {
        const state = queue.shift();
        const { currentNode, coords, distance, previousNode, path, direction } = state;

        if (distance >= CONFIG.MAX_ROUTE_DISTANCE) {
            if (distance > CONFIG.MAX_ROUTE_DISTANCE) {
                const partial = turf.lineSliceAlong(
                    turf.lineString(coords),
                    0,
                    CONFIG.MAX_ROUTE_DISTANCE,
                    { units: 'kilometers' }
                );
                routes.push(partial.geometry.coordinates);
                debugInfo.truncatedRoutes++;
            } else {
                routes.push(coords);
            }
            debugInfo.totalRoutes++;
            debugInfo.maxRouteLength = Math.max(debugInfo.maxRouteLength, distance);
            debugInfo.minRouteLength = Math.min(debugInfo.minRouteLength, distance);
            debugInfo.terminationReasons.max_distance++;
            terminationPoints.push({
                coords: coords[coords.length - 1],
                reason: 'max_distance',
                details: `${distance.toFixed(2)}km`
            });
            continue;
        }

        const nextEdges = network.adjacency.get(currentNode) || [];
        let advanced = false;

        for (const e of nextEdges) {
            debugInfo.processedEdges++;

            // Skip if edge leads back to previous node
            if (e.end === previousNode) {
                if (DEBUG.enabled) {
                    console.log(`Skipping backtrack to previous node ${previousNode}`);
                }
                continue;
            }

            // Check if edge has been visited
            const edgeKey = `${Math.min(e.start, e.end)}-${Math.max(e.start, e.end)}`;
            if (visitedEdges.has(edgeKey)) {
                if (DEBUG.enabled) {
                    console.log(`Edge ${edgeKey} already visited`);
                }
                continue;
            }

            let lineCoords = orientEdgeAtNode(network, e, currentNode);
            const segmentDist = turf.length(turf.lineString(lineCoords), { units: 'kilometers' });
            
            // Skip very short segments
            if (segmentDist < CONFIG.MIN_SEGMENT_LENGTH) {
                if (DEBUG.enabled) {
                    console.log(`Segment too short: ${segmentDist.toFixed(3)}km`);
                }
                continue;
            }

            const newDistance = distance + segmentDist;
            visitedEdges.add(edgeKey);

            if (newDistance > CONFIG.MAX_ROUTE_DISTANCE) {
                const needed = CONFIG.MAX_ROUTE_DISTANCE - distance;
                const partial = turf.lineSliceAlong(
                    turf.lineString(lineCoords),
                    0,
                    needed,
                    { units: 'kilometers' }
                );
                const combinedCoords = combineCoords(coords, partial.geometry.coordinates);
                routes.push(combinedCoords);
                debugInfo.truncatedRoutes++;
                debugInfo.totalRoutes++;
                terminationPoints.push({
                    coords: combinedCoords[combinedCoords.length - 1],
                    reason: 'max_distance',
                    details: `${newDistance.toFixed(2)}km`
                });
            } else {
                const combinedCoords = combineCoords(coords, lineCoords);
                queue.push({
                    currentNode: e.end,
                    coords: combinedCoords,
                    distance: newDistance,
                    previousNode: currentNode,
                    path: [...path, e.end],
                    direction
                });
            }
            advanced = true;
        }

        if (!advanced) {
            routes.push(coords);
            debugInfo.totalRoutes++;
            debugInfo.maxRouteLength = Math.max(debugInfo.maxRouteLength, distance);
            debugInfo.minRouteLength = Math.min(debugInfo.minRouteLength, distance);
            debugInfo.terminationReasons.no_advance++;

            const nextEdgeAnalysis = nextEdges.map(e => ({
                from: e.start,
                to: e.end,
                length: turf.length(turf.lineString(e.coords), { units: 'kilometers' }),
                wasVisited: visitedEdges.has(`${Math.min(e.start, e.end)}-${Math.max(e.start, e.end)}`),
                isBacktrack: e.end === previousNode
            }));

            terminationPoints.push({
                coords: coords[coords.length - 1],
                reason: 'no_advance',
                details: `Analyzed ${nextEdges.length} edges:\n` + 
                        nextEdgeAnalysis.map((analysis, idx) => 
                            `Edge ${idx + 1}:\n` +
                            `  - From node: ${analysis.from}\n` +
                            `  - To node: ${analysis.to}\n` +
                            `  - Length: ${analysis.length.toFixed(3)}km\n` +
                            `  - Visited: ${analysis.wasVisited}\n` +
                            `  - Backtrack: ${analysis.isBacktrack}`
                        ).join('\n')
            });
        }
    }

    if (DEBUG.enabled) {
        console.log('Route building statistics:', {
            ...debugInfo,
            terminationReasons: Object.entries(debugInfo.terminationReasons)
                .map(([reason, count]) => `${reason}: ${count}`)
                .join(', '),
            visitedEdges: visitedEdges.size
        });

        routes.forEach((route, index) => {
            const length = turf.length(turf.lineString(route), { units: 'kilometers' });
            console.log(`Route ${index}: ${length.toFixed(2)}km, ${route.length} points`);
        });
        visualizeDebugTermination(map, terminationPoints);

    }


    return { routes, debugInfo, terminationPoints };
}

// =====================
// Visualization Functions
// =====================

function visualizeDebug(network, routes, startPoint) {
    if (!DEBUG.enabled) return;

    // Remove existing debug layers
    ['debug-paths', 'debug-buffer', 'debug-search-area', 'debug-nodes'].forEach(id => {
        if (map.getLayer(id)) map.removeLayer(id);
        if (map.getSource(id)) map.removeSource(id);
    });
    // Visualize full network
    const allEdgeFeatures = network.edges.map((edge, index) => ({
        type: 'Feature',
        properties: { index },
        geometry: {
            type: 'LineString',
            coordinates: edge.coords
        }
    }));

    // Visualize network nodes
    const nodeFeatures = network.nodes.map((node, index) => ({
        type: 'Feature',
        properties: { index },
        geometry: {
            type: 'Point',
            coordinates: node
        }
    }));

    map.addSource('debug-nodes', {
        type: 'geojson',
        data: {
            type: 'FeatureCollection',
            features: nodeFeatures
        }
    });

    map.addLayer({
        id: 'debug-nodes',
        type: 'circle',
        source: 'debug-nodes',
        paint: {
            'circle-radius': 4,
            'circle-color': '#FF0000',
            'circle-opacity': 0.7
        }
    });

    // Visualize routes
    const routeFeatures = routes.map((route, index) => ({
        type: 'Feature',
        properties: {
            index,
            length: turf.length(turf.lineString(route), { units: 'kilometers' }).toFixed(2)
        },
        geometry: {
            type: 'LineString',
            coordinates: route
        }
    }));

    map.addSource('debug-paths', {
        type: 'geojson',
        data: {
            type: 'FeatureCollection',
            features: routeFeatures
        }
    });

    map.addLayer({
        id: 'debug-paths',
        type: 'line',
        source: 'debug-paths',
        paint: {
            'line-color': [
                'interpolate',
                ['linear'],
                ['get', 'index'],
                0, '#FF0000',
                routes.length, '#0000FF'
            ],
            'line-width': 3,
            'line-opacity': 0.6
        }
    });

    // Add search area visualization
    const searchArea = turf.circle(
        [startPoint.lng, startPoint.lat],
        CONFIG.INITIAL_SEARCH_AREA_RADIUS,
        { units: 'kilometers' }
    );

    map.addSource('debug-search-area', {
        type: 'geojson',
        data: searchArea
    });

    map.addLayer({
        id: 'debug-search-area',
        type: 'line',
        source: 'debug-search-area',
        paint: {
            'line-color': '#FF0000',
            'line-width': 2,
            'line-dasharray': [2, 2]
        }
    });
}
function visualizeDebugTermination(map, terminationPoints) {
    // Remove existing layers if any
    if (map.getLayer('debug-termination')) map.removeLayer('debug-termination');
    if (map.getSource('debug-termination')) map.removeSource('debug-termination');

    // Remove existing event listeners
    map.off('click', 'debug-termination');
    map.off('mouseenter', 'debug-termination');
    map.off('mouseleave', 'debug-termination');

    const features = terminationPoints.map(point => ({
        type: 'Feature',
        properties: {
            reason: point.reason,
            details: point.details
        },
        geometry: {
            type: 'Point',
            coordinates: point.coords
        }
    }));

    // Add the source and layer
    map.addSource('debug-termination', {
        type: 'geojson',
        data: {
            type: 'FeatureCollection',
            features: features
        }
    });

    map.addLayer({
        id: 'debug-termination',
        type: 'circle',
        source: 'debug-termination',
        paint: {
            'circle-radius': 6,
            'circle-color': [
                'match',
                ['get', 'reason'],
                'sharp_turn', '#ff0000',    // Red
                'cycle', '#ffff00',         // Yellow
                'max_distance', '#00ff00',  // Green
                'no_advance', '#0000ff',    // Blue
                '#ff00ff'                   // Pink (default)
            ],
            'circle-opacity': 0.7,
            'circle-stroke-width': 1,
            'circle-stroke-color': '#ffffff'
        }
    });

    // Add click handler
    map.on('click', 'debug-termination', (e) => {
        if (!e.features.length) return;

        const feature = e.features[0];
        const reason = feature.properties.reason;
        const details = feature.properties.details;

        const reasonLabels = {
            'sharp_turn': 'Sharp Turn',
            'cycle': 'Cycle Detected',
            'max_distance': 'Maximum Distance Reached',
            'no_advance': 'No Valid Next Edges'
        };

        new maplibregl.Popup()
            .setLngLat(e.lngLat)
            .setHTML(`
                <div style="padding: 10px; font-family: Arial, sans-serif;">
                    <div style="font-weight: bold; margin-bottom: 5px;">
                        ${reasonLabels[reason] || reason}
                    </div>
                    <div style="color: #666;">
                        ${details}
                    </div>
                </div>
            `)
            .addTo(map);
    });

    // Add hover effects
    map.on('mouseenter', 'debug-termination', () => {
        map.getCanvas().style.cursor = 'pointer';
    });

    map.on('mouseleave', 'debug-termination', () => {
        map.getCanvas().style.cursor = '';
    });

    if (DEBUG.enabled) {
        console.log('Debug visualization added:', {
            totalPoints: features.length,
            byReason: features.reduce((acc, f) => {
                acc[f.properties.reason] = (acc[f.properties.reason] || 0) + 1;
                return acc;
            }, {})
        });
    }
}
// =====================
// Main Function with Debug Support
// =====================

async function findSignpostDirections(signpostPoint, signpostName) {
    DEBUG.logConfig();
    console.log('Starting findSignpostDirections with point:', signpostPoint);

    // Fetch and process features
    const rawPaths = map.querySourceFeatures('thunderforest-outdoors', { sourceLayer: 'path' });
    const rawRoads = map.querySourceFeatures('thunderforest-outdoors', { sourceLayer: 'road' });

    if (DEBUG.enabled) {
        console.log('Raw features found:', {
            paths: rawPaths.length,
            roads: rawRoads.length
        });
    }

    // Process features
    let lineFeatures = [...rawPaths, ...rawRoads].map(f => ({
        type: 'Feature',
        properties: f.properties || {},
        geometry: f.geometry || null
    }));

    // Handle MultiLineString features
    lineFeatures = lineFeatures.flatMap(f => {
        if (!f.geometry) return [];
        if (f.geometry.type === 'LineString') return [f];
        if (f.geometry.type === 'MultiLineString') {
            return f.geometry.coordinates.map(coords => ({
                type: 'Feature',
                properties: { ...f.properties },
                geometry: { type: 'LineString', coordinates: coords }
            }));
        }
        return [];
    });

// Build network
    const network = buildPathNetwork(lineFeatures);
    DEBUG.logNetwork(network);

    // Find start node
    const point = turf.point([signpostPoint.lng, signpostPoint.lat]);
    const startNode = findClosestNode(point, network.nodes);
    
    if (startNode === null) {
        console.warn('No paths/roads found near the signpost.');
        return { results: [], signpostName };
    }

    // Build and analyze routes
    const { routes, debugInfo: routeDebugInfo } = buildRoutesFromSignpost(network, startNode, signpostPoint);
    
    if (DEBUG.enabled) {
        console.log('Route generation complete:', routeDebugInfo);
        visualizeDebug(network, routes, signpostPoint);
    }

    // Find POIs along routes
    const results = findPOIsForRoutes(routes, signpostPoint, 'hiking');

    return {
        results,
        signpostName,
        debugInfo: {
            network: network.debugInfo,
            routes: routeDebugInfo,
            totalPOIs: results.reduce((sum, r) => sum + r.destinations.length, 0)
        }
    };
}


// =====================
// Enhanced POI Detection with Debug Support
// =====================

function sortPOIsByPriority(pois) {
    return pois.sort((a, b) => {
        // First sort by priority
        const priorityA = POI_PRIORITIES[a.type] || 999;
        const priorityB = POI_PRIORITIES[b.type] || 999;
        if (priorityA !== priorityB) return priorityA - priorityB;
        
        // Then by distance if same priority
        return a.distance - b.distance;
    });
}

const POI_PRIORITIES = {
    'peak': 1,
    'saddle': 2,
    'parking': 3,
    'shelter': 4,
    'alpine_hut': 4,
    'information': 5,  // signposts
    'spring': 6,
    'water_point': 6
};

function findPOIsForRoutes(routes, startPoint, difficulty) {
    const directionGroups = new Map();
    const debugInfo = {
        totalPOIs: 0,
        poisPerRoute: [],
        bufferSize: CONFIG.POI_SEARCH_BUFFER,
        originalRoutes: routes.length,
        directionsFound: 0,
        skippedNearbyPOIs: 0
    };

    // First, group routes by their initial direction
    routes.forEach((routeCoords) => {
        const pointIndex = Math.min(10, routeCoords.length - 1);
        
        const direction = calculatePathDirection(startPoint, routeCoords);
        validateDirectionCalculation(startPoint, routeCoords, direction);
        
        if (!directionGroups.has(direction)) {
            directionGroups.set(direction, []);
            debugInfo.directionsFound++;
        }
        directionGroups.get(direction).push(routeCoords);
    });

    if (DEBUG.enabled) {
        console.log('Direction groups found:', directionGroups.size);
        directionGroups.forEach((routes, direction) => {
            console.log(`${direction}: ${routes.length} routes`);
        });
    }

    const results = [];
    
    // Create a buffer around the signpost to check for nearby POIs
    const signpostPoint = turf.point([startPoint.lng, startPoint.lat]);
    const signpostBuffer = turf.buffer(signpostPoint, CONFIG.MIN_POI_DISTANCE, { units: 'kilometers' });
    
    // Process each direction group
    for (const [direction, directionRoutes] of directionGroups) {
        const poiMap = new Map();
        let directionPOIs = 0;

        // Process routes for this direction
        directionRoutes.forEach((routeCoords) => {
            const routeLine = turf.lineString(routeCoords);
            const buffer = turf.buffer(routeLine, CONFIG.POI_SEARCH_BUFFER, { units: 'kilometers' });

            // Query POIs with priorities
            const regularPois = map.querySourceFeatures('thunderforest-outdoors', {
                sourceLayer: 'poi-label',
                filter: ['match',
                    ['get', 'feature'],
                    ['peak', 'saddle', 'col', 'shelter', 'alpine_hut', 'spring', 'water_point', 'parking', 'viewpoint'],
                    true,
                    false
                ]
            });

            const signposts = map.querySourceFeatures('thunderforest-outdoors', {
                sourceLayer: 'poi-label',
                filter: ['all',
                    ['==', ['get', 'feature'], 'information'],
                    ['==', ['get', 'information'], 'guidepost']
                ]
            }).filter(poi => poi.properties.name !== startPoint.name);

            const pois = [...regularPois, ...signposts];
            
            pois.forEach(poi => {
                if (!poi.geometry?.coordinates) return;
                
                const poiPoint = turf.point(poi.geometry.coordinates);

                // Skip POIs that are too close to the signpost
                if (turf.booleanPointInPolygon(poiPoint, signpostBuffer)) {
                    debugInfo.skippedNearbyPOIs++;
                    return;
                }
                
                if (!turf.booleanPointInPolygon(poiPoint, buffer)) return;

                const nearestOnPath = turf.nearestPointOnLine(routeLine, poiPoint);
                const slicedPath = turf.lineSlice(
                    signpostPoint,
                    nearestOnPath,
                    routeLine
                );
                const distanceAlongPath = turf.length(slicedPath, { units: 'kilometers' });

                // Skip if distance is less than minimum
                if (distanceAlongPath < CONFIG.MIN_POI_DISTANCE) {
                    debugInfo.skippedNearbyPOIs++;
                    return;
                }

                const poiName = poi.properties.name || 
                    `${poi.properties.feature} (${poi.properties.ele}m)`;

                // Update POI only if it's closer than existing one or has higher priority
                const existingPOI = poiMap.get(poiName);
                const newPriority = POI_PRIORITIES[poi.properties.feature] || 999;
                
                if (!existingPOI || 
                    newPriority < (POI_PRIORITIES[existingPOI.type] || 999) ||
                    (newPriority === (POI_PRIORITIES[existingPOI.type] || 999) && distanceAlongPath < existingPOI.distance)) {
                    
                    poiMap.set(poiName, {
                        name: poiName,
                        type: poi.properties.feature,
                        priority: newPriority,
                        distance: distanceAlongPath,
                        elevation: poi.properties.ele || 0,
                        time: calculateHikingTime(
                            distanceAlongPath,
                            Math.max(0, (poi.properties.ele || 0) - startPoint.ele),
                            difficulty
                        )
                    });
                    directionPOIs++;
                }
            });
        });

        debugInfo.poisPerRoute.push(directionPOIs);
        debugInfo.totalPOIs += directionPOIs;

        // Convert POI map to array, sort by priority and distance
        const destinations = Array.from(poiMap.values())
            .sort((a, b) => {
                if (a.priority !== b.priority) {
                    return a.priority - b.priority;
                }
                return a.distance - b.distance;
            })
            .slice(0, 3); // Take only top 3 POIs

        if (destinations.length > 0) {
            results.push({
                direction,
                difficulty,
                destinations
            });
        }
    }

    // Only keep directions that have POIs beyond the minimum distance
    const finalResults = results
        .filter(result => result.destinations.length > 0)
        .sort((a, b) => {
            const priorityA = Math.min(...a.destinations.map(d => d.priority));
            const priorityB = Math.min(...b.destinations.map(d => d.priority));
            if (priorityA !== priorityB) {
                return priorityA - priorityB;
            }
            return Math.min(...a.destinations.map(d => d.distance)) - 
                   Math.min(...b.destinations.map(d => d.distance));
        })
        //.slice(0, 3);  // Remove this line

    if (DEBUG.enabled) {
        console.log('Results consolidated:', {
            originalRoutes: debugInfo.originalRoutes,
            uniqueDirections: directionGroups.size,
            directionsWithPOIs: debugInfo.directionsFound,
            finalDirections: finalResults.length,
            totalUniquePOIs: debugInfo.totalPOIs,
            skippedNearbyPOIs: debugInfo.skippedNearbyPOIs
        });
    }

    return finalResults;
}


// Export debug controls
window.debugControls = {
    toggleDebug: () => {
        DEBUG.enabled = !DEBUG.enabled;
        console.log('Debug mode:', DEBUG.enabled ? 'enabled' : 'disabled');
    },
    setConfig: (key, value) => {
        if (key in CONFIG) {
            CONFIG[key] = value;
            DEBUG.logConfig();
        } else {
            console.warn('Unknown configuration key:', key);
        }
    },
    getConfig: () => ({...CONFIG}),
    visualize: (network, routes, startPoint) => visualizeDebug(network, routes, startPoint)
};

async function initializeThunderforestLayers() {
    try {
        console.log('Starting Thunderforest initialization...');
        const apiKey = 'bbb81d9ac1334825af992c8f0a09ea25';
        const MAX_DISTANCE_KM = 4;

        if (map.getSource('thunderforest-outdoors')) {
            map.removeSource('thunderforest-outdoors');
        }

        // Create the distance filter using a circle
        function createDistanceFilter() {
            const center = map.getCenter();
            const radius = MAX_DISTANCE_KM;  // Keep in km for turf
            const circle = turf.circle([center.lng, center.lat], radius, {
                steps: 64,
                units: 'kilometers'
            });
            
            return ['within', circle];
        }

        // Add source
        map.addSource('thunderforest-outdoors', {
            type: 'vector',
            tiles: [
                `https://a.tile.thunderforest.com/thunderforest.outdoors-v2/{z}/{x}/{y}.vector.pbf?apikey=${apiKey}`,
                `https://b.tile.thunderforest.com/thunderforest.outdoors-v2/{z}/{x}/{y}.vector.pbf?apikey=${apiKey}`,
                `https://c.tile.thunderforest.com/thunderforest.outdoors-v2/{z}/{x}/{y}.vector.pbf?apikey=${apiKey}`
            ],
            maxzoom: 14
        });

        // Wait for source to be loaded
        await new Promise((resolve) => {
            const checkSource = () => {
                if (map.isSourceLoaded('thunderforest-outdoors')) {
                    resolve();
                } else {
                    map.once('sourcedata', checkSource);
                }
            };
            checkSource();
        });

        // Create the initial distance filter
        const distanceFilter = createDistanceFilter();

        map.on('sourcedata', (e) => {
            if (e.sourceId === 'thunderforest-outdoors' && e.isSourceLoaded) {
                const features = map.querySourceFeatures('thunderforest-outdoors', {
                    sourceLayer: 'path'
                });
                console.log('Path features loaded:', features.length);
            }
        });

        // Add all layers with distance filtering
        map.addLayer({
            'id': 'paths-hit-area',
            'type': 'line',
            'source': 'thunderforest-outdoors',
            'source-layer': 'path',
            'filter': distanceFilter,
            'layout': {
                'visibility': 'none',
                'line-join': 'round',
                'line-cap': 'round'
            },
            'paint': {
                'line-color': '#000000',
                'line-width': 20,
                'line-opacity': 0
            }
        }, 'refuges-layer');

        map.addLayer({
            'id': 'paths-outline',
            'type': 'line',
            'source': 'thunderforest-outdoors',
            'source-layer': 'path',
            'filter': distanceFilter,
            'layout': {
                'visibility': 'none',
                'line-join': 'round',
                'line-cap': 'round'
            },
            'paint': {
                'line-color': '#FFFFFF',
                'line-width': [
                    'case',
                    ['boolean', ['feature-state', 'selected'], false],
                    15,
                    0
                ],
                'line-opacity': 0.5
            }
        }, 'paths-hit-area');

        map.addLayer({
            'id': 'paths',
            'type': 'line',
            'source': 'thunderforest-outdoors',
            'source-layer': 'path',
            'filter': distanceFilter,
            'layout': {
                'visibility': 'none',
                'line-join': 'round',
                'line-cap': 'round'
            },
            'paint': {
                'line-color': [
                    'match',
                    ['get', 'sac_scale'],
                    'hiking', '#4444FF',
                    'mountain_hiking', '#44FF44',
                    'demanding_mountain_hiking', '#FFFF44',
                    'alpine_hiking', '#FFA500',
                    'demanding_alpine_hiking', '#FF4444',
                    'difficult_alpine_hiking', '#FF0000',
                    '#4444FF'
                ],
                'line-width': [
                    'interpolate',
                    ['linear'],
                    ['zoom'],
                    10, 2,
                    16, 4
                ],
                'line-opacity': [
                    'interpolate',
                    ['linear'],
                    ['zoom'],
                    15, 0,
                    17, 1
                ],
                'line-opacity-transition': {
                    'duration': 2000,
                    'delay': 0
                }
            }
        }, 'paths-outline');

        map.addLayer({
            'id': 'path-difficulty-markers',
            'type': 'symbol',
            'source': 'thunderforest-outdoors',
            'source-layer': 'path',
            'filter': distanceFilter,
            'layout': {
                'visibility': 'none',
                'symbol-placement': 'line',
                'symbol-spacing': 300,
                'text-field': [
                    'match',
                    ['get', 'sac_scale'],
                    'hiking', 'T1',
                    'mountain_hiking', 'T2',
                    'demanding_mountain_hiking', 'T3',
                    'alpine_hiking', 'T4',
                    'demanding_alpine_hiking', 'T5',
                    'difficult_alpine_hiking', 'T6',
                    ''
                ],
                'text-size': 12,
                'text-font': ['Noto Sans Regular'],
                'text-allow-overlap': false,
                'text-ignore-placement': false,
                'text-padding': 2
            },
            'paint': {
                'text-color': [
                    'match',
                    ['get', 'sac_scale'],
                    'hiking', '#4444FF',
                    'mountain_hiking', '#44FF44',
                    'demanding_mountain_hiking', '#FFFF44',
                    'alpine_hiking', '#FFA500',
                    'demanding_alpine_hiking', '#FF4444',
                    'difficult_alpine_hiking', '#FF0000',
                    '#4444FF'
                ],
                'text-halo-color': '#ffffff',
                'text-halo-width': 2,
                'text-opacity': [
                    'interpolate',
                    ['linear'],
                    ['zoom'],
                    15, 0,
                    16, 1
                ],
                'text-opacity-transition': {
                    'duration': 2000,
                    'delay': 0
                }
            }
        });

        map.addLayer({
            'id': 'hiking-routes',
            'type': 'line',
            'source': 'thunderforest-outdoors',
            'source-layer': 'hiking',
            'filter': distanceFilter,
            'layout': {
                'visibility': 'none',
                'line-join': 'round',
                'line-cap': 'round'
            },
            'paint': {
                'line-color': '#FF4444',
                'line-width': [
                    'interpolate',
                    ['linear'],
                    ['zoom'],
                    10, 1,
                    16, 3
                ],
                'line-opacity': [
                    'interpolate',
                    ['linear'],
                    ['zoom'],
                    15, 0,
                    17, 1
                ],
                'line-opacity-transition': {
                    'duration': 2000,
                    'delay': 0
                }
            }
        });

        // Load icons first (add this before adding the layer)
        const iconNames = [
            'peak',
            'alpine_hut',
            'shelter',
            'viewpoint',
            'saddle',
            'eau',
            'cave',
            'camp_site',
            'picnic_site',
            'information',
            'guidepost',
            'parking',
            'water_point'
        ];

        await Promise.all(
            iconNames.map(iconName => 
                new Promise((resolve, reject) => {
                    const img = new Image();
                    img.onload = () => {
                        const canvas = document.createElement('canvas');
                        const size = 20; // Standard size for all icons
                        canvas.width = size;
                        canvas.height = size;
                        const ctx = canvas.getContext('2d');
                        ctx.drawImage(img, 0, 0, size, size);
                        map.addImage(iconName, ctx.getImageData(0, 0, size, size));
                        resolve();
                    };
                    img.onerror = () => {
                        console.warn(`Failed to load icon: ${iconName}`);
                        resolve(); // Resolve anyway to continue loading other icons
                    };
                    img.src = `/icons/${iconName}.png`; // Adjust path as needed
                })
            )
        );

        // Add the POI layer with icons
        map.addLayer({
            'id': 'poisth',
            'type': 'symbol',
            'source': 'thunderforest-outdoors',
            'source-layer': 'poi-label',
            'minzoom': 14,
            'filter': ['all',
                distanceFilter,
                ['match',
                    ['get', 'feature'],
                    [   
                        'peak',
                        'alpine_hut',
                        'shelter',
                        'viewpoint',
                        'saddle',
                        'spring',
                        'cave',
                        'camp_site',
                        'picnic_site',
                        'information',
                        'guidepost',
                        'parking',
                        'water_point'
                    ],
                    true,
                    false
                ]
            ],
            'layout': {
                'visibility': 'visible',
                'icon-image': [
                    'match',
                    ['get', 'feature'],
                    'peak', 'peak',
                    'alpine_hut', 'shelter',
                    'shelter', 'shelter',
                    'viewpoint', 'viewpoint',
                    'saddle', 'saddle',
                    'spring', 'eau',
                    'cave', 'cave',
                    'camp_site', 'camp_site',
                    'picnic_site', 'picnic_site',
                    'information', 'information',
                    'guidepost', 'guidepost',
                    'parking', 'parking',
                    'water_point', 'water_point',
                    'alpine_hut'
                ],
                'icon-size': 1.4,
                'icon-allow-overlap': false,
                'icon-offset': [0, -10],
                'text-field': [
                    'case',
                    ['match',
                        ['get', 'feature'],
                        [
                            'spring', 
                            'water_point', 
                            'information',
                            'parking',
                            'viewpoint',
                            'picnic_site',
                            'camp_site'
                        ],
                        true,
                        false
                    ],
                    '',  // No text for matched features
                    ['get', 'name']  // Show text for everything else
                ],
                'text-font': ['Noto Sans Regular'],
                'text-size': 12,
                'text-offset': [0, 1],
                'text-anchor': 'top'
            },
            'paint': {
                'icon-opacity': [
                    'interpolate',
                    ['linear'],
                    ['zoom'],
                    13, ['match',
                        ['get', 'feature'],
                        'peak', 0,
                        0  // Everything starts hidden
                    ],
                    14, ['match',
                        ['get', 'feature'],
                        'peak', 1,  // Peaks fade in at 14
                        0   // Everything else stays hidden
                    ],
                    15, ['match',
                        ['get', 'feature'],
                        'peak', 1,
                        ['spring', 'water_point'], 1,  // Water sources fade in at 15
                        0   // Everything else stays hidden
                    ],
                    16, ['match',
                        ['get', 'feature'],
                        ['peak', 'spring', 'water_point'], 1,
                        0   // Start fading in everything else
                    ],
                    17, 1  // Everything fully visible
                ],
                'icon-opacity-transition': {
                    'duration': 2000,
                    'delay': 0
                },
                'text-color': [
                    'match',
                    ['get', 'feature'],
                    'peak', '#FF4444',
                    'alpine_hut', '#4444FF',
                    'shelter', '#44FF44',
                    'viewpoint', '#FF8C00',
                    'saddle', '#8B4513',
                    'spring', '#4682B4',
                    'cave', '#8B4513',
                    'camp_site', '#228B22',
                    'picnic_site', '#32CD32',
                    'information', '#4B0082',
                    'guidepost', '#DAA520',
                    'parking', '#4444FF',
                    'water_point', '#4682B4',
                    '#000000'
                ],
                'text-halo-color': '#ffffff',
                'text-halo-width': 2
            }
        });

map.on('click', 'poisth', async (e) => {
    const f = e.features[0];
    if (f.properties.feature === 'information' && f.properties.information === 'guidepost') {
        console.log('Processing signpost:', f.properties);

        const signpostPoint = {
            lng: e.lngLat.lng,
            lat: e.lngLat.lat,
            ele: f.properties.ele || 'N/A',
            name: f.properties.name || 'Unknown'
        };

        try {
            const { results, network, routes } = await findSignpostDirections(signpostPoint, signpostPoint.name);

            if (network && routes) {
                visualizeDebug(network, routes, signpostPoint);
            }

            const popupContent = createSignpostPopup(results, signpostPoint.name, signpostPoint.ele);
            new maplibregl.Popup({
                closeButton: true,
                closeOnClick: false
            })
                .setLngLat([signpostPoint.lng, signpostPoint.lat])
                .setHTML(popupContent)
                .addTo(map);

        } catch (error) {
            console.error('Error processing signpost:', error);
            new maplibregl.Popup()
                .setLngLat([signpostPoint.lng, signpostPoint.lat])
                .setHTML(`
                    <div style="padding:10px; font-family: Arial;">
                        <strong style="color: red;">${signpostPoint.name}</strong><br>
                        <span style="color: red;">Altitude: ${signpostPoint.ele}m</span><br>
                        <div style="color: #666;">Error processing this signpost</div>
                    </div>
                `)
                .addTo(map);
        }
    }
});









        map.addLayer({
            'id': 'thunderforest-parking',
            'type': 'fill',
            'source': 'thunderforest-outdoors',
            'source-layer': 'landuse',
            'filter': ['all', ['==', ['get', 'type'], 'parking'], distanceFilter],
            'layout': { 'visibility': 'visible' },
            'paint': {
                'fill-color': '#4444FF',
                'fill-opacity': 0.5,
                'fill-outline-color': '#2222FF'
            }
        }, 'refuges-layer');

        map.addLayer({
            'id': 'thunderforest-roads',
            'type': 'line',
            'source': 'thunderforest-outdoors',
            'source-layer': 'road',
            'filter': distanceFilter,
            'layout': {
                'visibility': 'none',
                'line-join': 'round',
                'line-cap': 'round'
            },
            'paint': {
                'line-color': [
                    'match',
                    ['get', 'highway'],
                    'motorway', '#FF4444',
                    'trunk', '#FF8C00',
                    'primary', '#FFA500',
                    'secondary', '#FFD700',
                    'tertiary', '#FFEB3B',
                    '#FFFFFF'
                ],
                'line-width': [
                    'interpolate',
                    ['linear'],
                    ['zoom'],
                    10, 1,
                    16, 4
                ],
                'line-opacity': [
                    'interpolate',
                    ['linear'],
                    ['zoom'],
                    15, 0,
                    16, 1
                ],
                'line-opacity-transition': {
                    'duration': 2000,
                    'delay': 0
                }
            }
        }, 'refuges-layer');

        map.addLayer({
            'id': 'thunderforest-lakes',
            'type': 'fill',
            'source': 'thunderforest-outdoors',
            'source-layer': 'water',
            'filter': ['all', ['==', ['get', 'type'], 'water'], distanceFilter],
            'layout': { 'visibility': 'visible' },
            'paint': {
                'fill-color': '#4682B4',
                'fill-opacity': 1.0,
                'fill-translate': [
                    'interpolate',
                    ['linear'],
                    ['zoom'],
                    10, ['literal', [0, 0]],
                    18, ['literal', [100, 100]]
                ],
                'fill-pattern': {
                    'property': 'type',
                    'type': 'categorical',
                    'stops': [
                        ['water', 'water_texture']
                    ]
                }
            }
        });

        // Water texture setup
        const waterTextureImage = new Image();
        waterTextureImage.onload = () => {
            map.addImage('water_texture', waterTextureImage);
        };
        waterTextureImage.src = 'water_texture.webp';

        map.addImage('waterTextureImage', {
            width: 256,
            height: 256,
            data: getWaterTexture()
        });

        function getWaterTexture() {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = 256;
            canvas.height = 256;

            const gradient = context.createLinearGradient(0, 0, 256, 256);
            gradient.addColorStop(0, 'rgba(255, 255, 255, 0)');
            gradient.addColorStop(0.5, 'rgba(255, 255, 255, 0.5)');
            gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');

            context.fillStyle = gradient;
            context.fillRect(0, 0, 256, 256);

            return context.getImageData(0, 0, 256, 256).data;
        }


        map.on('moveend', () => {
            const newCircleFilter = createDistanceFilter();
            
            ['paths', 'paths-outline', 'paths-hit-area', 'path-difficulty-markers',
             'hiking-routes', 'thunderforest-roads'].forEach(layerId => {
                if (map.getLayer(layerId)) {
                    map.setFilter(layerId, newCircleFilter);
                }
            });

            ['thunderforest-parking', 'thunderforest-lakes'].forEach(layerId => {
                if (map.getLayer(layerId)) {
                    const typeFilter = layerId === 'thunderforest-parking' ?
                        ['==', ['get', 'type'], 'parking'] :
                        ['==', ['get', 'type'], 'water'];
                    map.setFilter(layerId, ['all', typeFilter, newCircleFilter]);
                }
            });

            if (map.getLayer('poisth')) {
                map.setFilter('poisth', ['all',
                    newCircleFilter,
                    ['match',
                        ['get', 'feature'],
                        [
                            'peak',
                            'alpine_hut',
                            'shelter',
                            'viewpoint',
                            'saddle',
                            'spring',
                            'cave',
                            'camp_site',
                            'picnic_site',
                            'information',
                            'guidepost',
                            'parking',
                            'water_point'
                        ],
                        true,
                        false
                    ]
                ]);
            }
        });

        // Click handling
        let selectedPathId = null;
        let justClickedPath = false;  // Flag to track path clicks

        // Handler for clicking on paths
        map.on('click', 'paths-hit-area', (e) => {
            justClickedPath = true;  // Set flag when clicking a path
            
            const bbox = [
                [e.point.x - 5, e.point.y - 5],
                [e.point.x + 5, e.point.y + 5]
            ];
            const features = map.queryRenderedFeatures(bbox, { layers: ['paths-hit-area'] });
            
            if (!features.length) return;

            const feature = features[0];
            
            if (selectedPathId !== feature.id) {
                // Deselect previous path if exists
                if (selectedPathId !== null) {
                    map.setFeatureState(
                        { source: 'thunderforest-outdoors', sourceLayer: 'path', id: selectedPathId },
                        { selected: false }
                    );
                }

                // Select new path
                selectedPathId = feature.id;
                map.setFeatureState(
                    { source: 'thunderforest-outdoors', sourceLayer: 'path', id: selectedPathId },
                    { selected: true }
                );
                map.getCanvas().style.cursor = 'pointer';

                // Show popup
                const properties = feature.properties;
                const content = `
                    <div style="max-width: 300px;">
                        ${properties.sac_scale ? `<p style="margin: 4px 0;"><strong>Difficult√©:</strong> ${properties.sac_scale.replace(/_/g, ' ')}</p>` : ''}
                        ${properties.trail_visibility ? `<p style="margin: 4px 0;"><strong>Visibilit√©:</strong> ${properties.trail_visibility}</p>` : ''}
                        ${properties.surface ? `<p style="margin: 4px 0;"><strong>Terrain:</strong> ${properties.surface}</p>` : ''}
                    </div>
                `;

                new maplibregl.Popup()
                    .setLngLat(e.lngLat)
                    .setHTML(content)
                    .addTo(map);
            }

            // Reset flag after a short delay to allow the map click handler to run
            setTimeout(() => {
                justClickedPath = false;
            }, 0);
        });

        // Handler for clicking anywhere on the map
        map.on('click', (e) => {
            // Only deselect if we didn't just click a path
            if (!justClickedPath && selectedPathId !== null) {
                map.setFeatureState(
                    { source: 'thunderforest-outdoors', sourceLayer: 'path', id: selectedPathId },
                    { selected: false }
                );
                selectedPathId = null;
                map.getCanvas().style.cursor = '';
            }
        });

        // Keep your existing hover effects
        map.on('mouseenter', 'paths-hit-area', () => {
            map.getCanvas().style.cursor = 'pointer';
        });

        map.on('mouseleave', 'paths-hit-area', () => {
            if (!selectedPathId) {
                map.getCanvas().style.cursor = '';
            }
        });

        // Layer controls
        const layerControls = [
            { id: 'thunderforest-paths-checkbox', label: 'Thunderforest Paths', layers: ['paths', 'paths-outline', 'paths-hit-area'] },
            { id: 'thunderforest-path-markers-checkbox', label: 'Path Difficulty Markers', layers: ['path-difficulty-markers'] },
            { id: 'thunderforest-parking-checkbox', label: 'Parking Areas', layers: ['thunderforest-parking'] },
            { id: 'thunderforest-Trek-checkbox', label: 'Trekking route', layers: ['hiking-routes'] },
            { id: 'thunderforest-lakes-checkbox', label: 'Lakes', layers: ['thunderforest-lakes'] },
            { id: 'thunderforest-water-checkbox', label: 'Water Sources', layers: ['thunderforest-water-sources'] },
            { id: 'thunderforest-roads-checkbox', label: 'Roads', layers: ['thunderforest-roads'] },
            { id: 'thunderforest-poi-checkbox', label: 'Points of Interest (thunderforest)', layers: ['poisth'] }
        ];

        // Create controls with event listeners
        const layerControl = document.querySelector('.layer-control');
        if (!layerControl) {
            console.error('Layer control container not found! Make sure you have <div class="layer-control"></div> in your HTML');
            return;
        }

        console.log('Creating layer controls...');
        layerControls.forEach(control => {
            const label = document.createElement('label');
            label.style.display = 'block';  // Make each control appear on a new line
            label.style.margin = '5px 0';   // Add some spacing
            label.innerHTML = `<input type="checkbox" id="${control.id}" checked> ${control.label}`;
            layerControl.appendChild(label);
            
            const checkbox = document.getElementById(control.id);
            if (!checkbox) {
                console.error(`Checkbox for ${control.id} not created properly`);
                return;
            }
            
            checkbox.addEventListener('change', (e) => {
                const visibility = e.target.checked ? 'visible' : 'none';
                if (Array.isArray(control.layers)) {
                    control.layers.forEach(layer => {
                        if (map.getLayer(layer)) {
                            map.setLayoutProperty(layer, 'visibility', visibility);
                        }
                    });
                } else {
                    if (map.getLayer(control.layers)) {
                        map.setLayoutProperty(control.layers, 'visibility', visibility);
                    }
                }
            });
        });

        console.log('Thunderforest initialization completed successfully');

    } catch (error) {
        console.error('Error initializing Thunderforest layers:', error);
        throw error;
    }
}
function rgbToHeight(r, g, b) {
    // The tree canopy tiles use a color scale where 
    // dark purple (128, 0, 128) represents 0m and 
    // bright green (0, 255, 0) represents 30m.

    // Normalize the color channels
    const rNorm = r / 255;
    const gNorm = g / 255; 
    const bNorm = b / 255;

    // Calculate the distance in color space from purple to green
    const purpleDistance = Math.sqrt(
        Math.pow(rNorm - 128/255, 2) + 
        Math.pow(gNorm - 0/255, 2) + 
        Math.pow(bNorm - 128/255, 2)
    );
    const greenDistance = Math.sqrt(
        Math.pow(rNorm - 0/255, 2) + 
        Math.pow(gNorm - 255/255, 2) + 
        Math.pow(bNorm - 0/255, 2)
    );

    // Interpolate the height based on the color distances
    const totalDistance = purpleDistance + greenDistance;
    const heightFraction = greenDistance / totalDistance;
    return heightFraction * 30;  
}
const treeDemProtocol = {
    transformRequest: (url, resourceType) => {
        return { url: url.replace('tree-dem://', 'https://') };
    },
    transformTile: (data, width, height) => {
        // Convert the colormap PNG data to terrain-rgb format
        const img = new Image();
        img.onload = () => {
            const canvas = document.createElement('canvas');
            canvas.width = width;
            canvas.height = height;
            const ctx = canvas.getContext('2d');
            ctx.drawImage(img, 0, 0);
            const imageData = ctx.getImageData(0, 0, width, height);

            // Convert colormap to height values
            const terrainData = new Uint8Array(width * height * 4);
            for (let i = 0; i < imageData.data.length; i += 4) {
                const r = imageData.data[i];
                const g = imageData.data[i + 1]; 
                const b = imageData.data[i + 2];
                const height = rgbToHeight(r, g, b);
                
                // Encode height into RGBA format
                const rgbHeight = height * 10;
                terrainData[i] = rgbHeight & 0xff;
                terrainData[i + 1] = (rgbHeight >> 8) & 0xff;
                terrainData[i + 2] = (rgbHeight >> 16) & 0xff;
                terrainData[i + 3] = 0xff;
            }

            return Promise.resolve(terrainData.buffer);
        };
        
        img.src = URL.createObjectURL(new Blob([data]));
    }
};

// Register the protocol
maplibregl.addProtocol('tree-dem', treeDemProtocol);



map.on('load', async () => {
    // Layer control setup
    const layerControl = document.querySelector('.layer-control');
    const refugeControl = document.createElement('label');
    refugeControl.innerHTML = '<input type="checkbox" id="refuges-checkbox" checked> Points of Interest';
    layerControl.appendChild(refugeControl);

    // Icon configuration
    const iconNames = {
        cabane: '/icons/shelter.png',
        refuge: '/icons/shelter.png',
        gite: '/icons/shelter.png',
        pt_eau: '/icons/eau.png',
        sommet: '/icons/summit.png',
        pt_passage: '/icons/summit.png',
        bivouac: '/icons/bivouac.png',
        lac: '/icons/lago.png'
    };

    // Icon Loading Function
    const loadIcon = (iconName, iconPath) => {
        console.log(`Attempting to load icon: ${iconName} from path: ${iconPath}`);
        return new Promise((resolve, reject) => {
            const img = new Image();
            img.crossOrigin = 'anonymous';
            
            img.onload = () => {
                const canvas = document.createElement('canvas');
                canvas.width = img.width;
                canvas.height = img.height;
                const ctx = canvas.getContext('2d');
                ctx.drawImage(img, 0, 0);
                map.addImage(iconName, ctx.getImageData(0, 0, img.width, img.height));
                resolve();
            };

            img.onerror = () => {
                const size = 32;
                const canvas = document.createElement('canvas');
                canvas.width = size;
                canvas.height = size;
                const ctx = canvas.getContext('2d');
                
                ctx.beginPath();
                ctx.arc(size/2, size/2, size/3, 0, Math.PI * 2);
                let fillColor = '#f5a442'; // Default orange

                switch(iconName) {
                    case 'pt_eau': fillColor = '#4287f5'; break;
                    case 'sommet':
                    case 'pt_passage': fillColor = '#ff4444'; break;
                    case 'refuge':
                    case 'cabane':
                    case 'gite': fillColor = '#42f554'; break;
                    case 'lac': fillColor = '#4682B4'; break;
                    case 'bivouac': fillColor = '#f5a442'; break;
                }
                
                ctx.fillStyle = fillColor;
                ctx.fill();
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 2;
                ctx.stroke();
                
                map.addImage(iconName, ctx.getImageData(0, 0, size, size));
                resolve();
            };

            img.src = iconPath;
        });
    };

    // Load all icons
    try {
        await Promise.all(
            Object.entries(iconNames).map(([iconName, iconPath]) => 
                loadIcon(iconName, iconPath)
            )
        );
    } catch (error) {
        console.error('Error in icon loading:', error);
    }

    // Remove existing layer and source if they exist
    if (map.getLayer('refuges-layer')) {
        map.removeLayer('refuges-layer');
    }
    if (map.getSource('refuges')) {
        map.removeSource('refuges');
    }

    // Add source
    map.addSource('refuges', {
        type: 'geojson',
        data: {
            type: 'FeatureCollection',
            features: []
        }
    });



    // Add layer
    map.addLayer({
        'id': 'refuges-layer',
        'type': 'symbol',
        'source': 'refuges',
        'layout': {
            'icon-image': [
                'case',
                ['has', 'photoId'], ['get', 'photoId'],
                ['match',
                    ['to-string', ['get', 'valeur', ['get', 'type']]],
                    'cabane non gard√©e', 'cabane',
                    'refuge gard√©', 'refuge',
                    "g√Æte d'√©tape", 'gite',
                    "point d'eau", 'pt_eau',
                    'sommet', 'sommet',
                    'point de passage', 'pt_passage',
                    'bivouac', 'bivouac',
                    'lac', 'lac',
                    'cabane'
                ]
            ],
            'icon-size': [
                'interpolate',
                ['linear'],
                ['zoom'],
                10, 0.1,
                15, 0.5
            ],
            'icon-allow-overlap': true,
            'icon-anchor': 'bottom',
            'text-field': ['get', 'nom'],
            'text-font': ['Noto Sans Regular'],
            'text-offset': [0, 0.5],
            'text-anchor': 'top',
            'text-size': 12,
            'text-rotation-alignment': 'viewport',
            'icon-rotation-alignment': 'viewport'
        },
        'paint': {
            'text-color': '#000',
            'text-halo-color': '#fff',
            'text-halo-width': 2
        }
    });

    // Create popup
    const popup = new maplibregl.Popup({
        closeButton: true,
        closeOnClick: false,
        maxWidth: 'none'
    });

    // Event Handlers
    map.on('click', 'refuges-layer', (e) => {
        if (e.features.length > 0) {
            const coordinates = e.features[0].geometry.coordinates.slice();
            const properties = e.features[0].properties;
            createPointPopup(coordinates, properties);
        }
    });

    // Add missing style handler
    map.on('styleimagemissing', (e) => {
        const id = e.id;
        const size = 32;
        const canvas = document.createElement('canvas');
        canvas.width = size;
        canvas.height = size;
        const ctx = canvas.getContext('2d');

        ctx.beginPath();
        ctx.arc(size/2, size/2, size/3, 0, Math.PI * 2);
        let fillColor = '#f5a442'; // Default orange

        if (id === 'pt_eau') fillColor = '#4287f5';
        else if (id === 'sommet' || id === 'pt_passage') fillColor = '#ff4444';
        else if (id === 'refuge' || id === 'cabane' || id === 'gite') fillColor = '#42f554';
        else if (id === 'lac') fillColor = '#4682B4';
        else if (id === 'bivouac') fillColor = '#f5a442';

        ctx.fillStyle = fillColor;
        ctx.fill();
        ctx.strokeStyle = '#ffffff';
        ctx.lineWidth = 2;
        ctx.stroke();

        map.addImage(id, ctx.getImageData(0, 0, size, size));
    });

    // Remove mouseleave event
    map.off('mouseleave', 'refuges-layer');

    // Add event listeners
    document.getElementById('refuges-checkbox').addEventListener('change', (e) => {
        const visibility = e.target.checked ? 'visible' : 'none';
        map.setLayoutProperty('refuges-layer', 'visibility', visibility);
        map.setLayoutProperty('refuges-hit-area', 'visibility', visibility);
    });

    // Add cleanup
    window.addEventListener('unload', () => {
        photoCache.clear();
        processedFeatures.clear();
    });

// Add Wikimedia source and layers
// Add Wikimedia source and layers
map.addSource('wikimedia', {
    type: 'geojson',
    data: {
        type: 'FeatureCollection',
        features: []
    },
    cluster: false,
    clusterMaxZoom: 14,
    clusterRadius: 30
});

map.addLayer({
    id: 'wikimedia-photos',
    type: 'circle',
    source: 'wikimedia',
    filter: ['!', ['has', 'point_count']],
    paint: {
        'circle-color': '#4287f5',
        'circle-radius': 8,
        'circle-opacity': [
            'interpolate',
            ['linear'],
            ['zoom'],
            16, 0,
            18, 1.0
        ],
        'circle-stroke-width': 2,
        'circle-stroke-color': '#fff',
        'circle-stroke-opacity': [
            'interpolate',
            ['linear'],
            ['zoom'],
            16, 0,
            18, 1.0
        ]
    }
});

// Then, after your existing layer control setup, add the Wikimedia control:
const wikimediaControl = document.createElement('label');
wikimediaControl.innerHTML = '<input type="checkbox" id="wikimedia-checkbox" checked> Wikimedia Photos';
layerControl.appendChild(wikimediaControl);

// Add Wikimedia toggle event listener
document.getElementById('wikimedia-checkbox').addEventListener('change', (e) => {
    const visibility = e.target.checked ? 'visible' : 'none';
    map.setLayoutProperty('wikimedia-clusters', 'visibility', visibility);
    map.setLayoutProperty('wikimedia-photos', 'visibility', visibility);
    map.setLayoutProperty('wikimedia-cluster-count', 'visibility', visibility);
});

map.on('click', 'wikimedia-photos', async (e) => {
    if (e.features.length > 0) {
        const feature = e.features[0];
        const title = feature.properties.url;
        const imgUrl = `https://commons.wikimedia.org/wiki/Special:FilePath/${encodeURIComponent(title)}?width=300`;
        const wikiUrl = `https://commons.wikimedia.org/wiki/File:${encodeURIComponent(title.replace('File:', ''))}`;
        
        // Show loading popup first
        const popup = new maplibregl.Popup()
            .setLngLat(feature.geometry.coordinates)
            .setHTML(`
                <div style="max-width: 300px;">
                    <p>Loading photo details...</p>
                </div>
            `)
            .addTo(map);

        // Fetch metadata
        const metadata = await fetchPhotoMetadata(title);
        
        if (metadata) {
            // Update popup with full information
            popup.setHTML(`
                <div style="max-width: 300px;">
                    <img src="${imgUrl}" style="width: 100%; height: auto;" alt="${title}">
                    <div style="margin-top: 10px; font-size: 0.9em;">
                        <p style="margin: 5px 0;"><strong>Author:</strong> ${metadata.author}</p>
                        <p style="margin: 5px 0;"><strong>License:</strong> ${metadata.license}</p>
                        <p style="margin: 5px 0;"><strong>Uploaded:</strong> ${metadata.dateUploaded}</p>
                        ${metadata.description ? `<p style="margin: 5px 0;"><strong>Description:</strong> ${metadata.description}</p>` : ''}
                        ${metadata.creditLine ? `<p style="margin: 5px 0;"><strong>Credit:</strong> ${metadata.creditLine}</p>` : ''}
                    </div>
                    <a href="${wikiUrl}" target="_blank" style="display: block; margin-top: 10px;">View on Wikimedia Commons</a>
                </div>
            `);
        }
    }
});

// Add click handler for clusters
map.on('click', 'wikimedia-clusters', (e) => {
    const features = map.queryRenderedFeatures(e.point, { layers: ['wikimedia-clusters'] });
    const clusterId = features[0].properties.cluster_id;
    map.getSource('wikimedia').getClusterExpansionZoom(clusterId, (err, zoom) => {
        if (err) return;

        map.easeTo({
            center: features[0].geometry.coordinates,
            zoom: zoom
        });
    });
});

// Add cursor styling
map.on('mouseenter', 'wikimedia-photos', () => {
    map.getCanvas().style.cursor = 'pointer';
});

map.on('mouseleave', 'wikimedia-photos', () => {
    map.getCanvas().style.cursor = '';
});

map.on('mouseenter', 'wikimedia-clusters', () => {
    map.getCanvas().style.cursor = 'pointer';
});

map.on('mouseleave', 'wikimedia-clusters', () => {
    map.getCanvas().style.cursor = '';
});

// Add the fetchWikimediaPhotos function after your existing fetch functions
function fetchWikimediaPhotos() {
    const currentZoom = map.getZoom();
    if (currentZoom >= 15) {
        const bounds = map.getBounds();
        const url = `https://commons.wikimedia.org/w/api.php?action=query&list=geosearch&gsbbox=${bounds.getNorth()}|${bounds.getWest()}|${bounds.getSouth()}|${bounds.getEast()}&gsnamespace=6&gslimit=500&format=json&origin=*`;
        
        fetch(url)
            .then(response => response.json())
            .then(data => {
                if (!data.query || !data.query.geosearch) return;
                
                const features = data.query.geosearch.map(item => ({
                    type: 'Feature',
                    geometry: {
                        type: 'Point',
                        coordinates: [item.lon, item.lat]
                    },
                    properties: {
                        title: item.title,
                        url: item.title,
                        pageid: item.pageid
                    }
                }));
                
                map.getSource('wikimedia').setData({
                    type: 'FeatureCollection',
                    features: features
                });
            })
            .catch(error => console.error('Error fetching Wikimedia photos:', error));
    } else {
        // Clear the Wikimedia data when outside the desired zoom range
        map.getSource('wikimedia').setData({
            type: 'FeatureCollection',
            features: []
        });
    }
}

// Add a function to fetch photo metadata
async function fetchPhotoMetadata(title) {
    const url = `https://commons.wikimedia.org/w/api.php?action=query&prop=imageinfo&iiprop=user|timestamp|extmetadata&titles=${encodeURIComponent(title)}&format=json&origin=*`;
    
    try {
        const response = await fetch(url);
        const data = await response.json();
        const pages = data.query.pages;
        const pageId = Object.keys(pages)[0];
        const imageInfo = pages[pageId].imageinfo?.[0];
        
        if (imageInfo) {
            const metadata = imageInfo.extmetadata || {};
            return {
                author: metadata.Artist?.value || imageInfo.user || 'Unknown',
                license: metadata.License?.value || 'Unknown license',
                description: metadata.ImageDescription?.value || '',
                dateUploaded: new Date(imageInfo.timestamp).toLocaleDateString(),
                creditLine: metadata.Credit?.value || ''
            };
        }
        return null;
    } catch (error) {
        console.error('Error fetching photo metadata:', error);
        return null;
    }
}

// Add throttled fetch to your existing moveend handler
const throttledFetchAll = throttle(() => {
    fetchPointsOfInterest(map);
    fetchWikimediaPhotos();
}, THROTTLE_DELAY);

// Initialize fetching
fetchWikimediaPhotos();
map.on('moveend', throttledFetchAll);


console.log('Map loaded, initializing Thunderforest...');
try {
    await initializeThunderforestLayers();
    console.log('Thunderforest initialization successful');
} catch (error) {
    console.error('Failed to initialize Thunderforest:', error);
}
// Call this after the map and source are loaded
map.once('idle', inspectPOIs);

const features = map.querySourceFeatures('thunderforest-outdoors', {
    sourceLayer: 'poi-label'
});
console.log(features);  

//////end of mapload
});

    

// Setup MapLibre protocol
demSource.setupMaplibre(maplibregl);


// Caches for generated terrain-rgb tiles
const terrainCache = new Map();
const pendingTiles = new Map();

// Constants
const DEM_TILE_CACHE_LIMIT = 6000;
const QUEUE_LIMIT = 200;
const MAX_CONCURRENT_FETCHES = 200;



// Worker Pool Implementation
   const workerPool = {
   workers: [],
   maxWorkers: navigator.hardwareConcurrency || 10,
   nextWorker: 0,
   busy: [],
   queue: [],
   queueLimit: QUEUE_LIMIT,
   lastMapState: { bearing: 0, pitch: 0 },

   initialize() {
       for (let i = 0; i < this.maxWorkers; i++) {
           const worker = new Worker('worker_maplibre.js');
           this.workers.push(worker);
           this.busy.push(false);
           worker.onmessage = this.createMessageHandler(i);
           worker.onerror = this.createErrorHandler(i);
       }
       console.log(`Initialized worker pool with ${this.maxWorkers} workers`);
   },

    createMessageHandler(index) {
        return (e) => {
            this.busy[index] = false;
            if (e.data.type === 'demTile') {
                const { z, x, y, pngBlob, duration } = e.data.data;
                const tileKey = `${z}/${x}/${y}`;
                const priority = this.calculatePriority(z, x, y);
                
                console.log(`Worker ${index} completed ${tileKey} in ${duration.toFixed(2)}ms (priority: ${priority.toFixed(2)})`);
                
                if (pendingTiles.has(tileKey)) {
                    pendingTiles.get(tileKey).resolve(pngBlob);
                    pendingTiles.delete(tileKey);
                    this.preloadAdjacentTiles(z, x, y);
                }
            }
            this.processQueue();
        };
    },

   createErrorHandler(index) {
       return (e) => {
           this.busy[index] = false;
           console.error(`Worker ${index} error:`, e);
           this.processQueue();
       };
   },

   getAvailableWorker() {
       const index = this.busy.findIndex(b => !b);
       if (index !== -1) {
           this.busy[index] = true;
           return this.workers[index];
       }
       return null;
   },

calculatePriority(z, x, y) {
    // Current factors:
    let priority = Math.min(19 - z, 10);  // Base priority from zoom level
    
    // Get current map state
    const bearing = map.getBearing();
    const pitch = map.getPitch();
    const center = map.getCenter();
    
    // Calculate tile position relative to view
    const tileLat = this.tile2lat(y + 0.5, z);
    const tileLon = (x / Math.pow(2, z)) * 360 - 180;
    
    // Distance from center
    const dy = tileLat - center.lat;
    const dx = tileLon - center.lng;
    const distance = Math.sqrt(dx * dx + dy * dy);
    
    // Viewing angle calculations
    const tileAngle = (Math.atan2(dy, dx) * 180 / Math.PI + 360) % 360;
    const viewingAngle = (bearing + 360) % 360;
    const angleDiff = Math.abs(tileAngle - viewingAngle);

    // Enhanced priority calculations
    
    // 1. View Direction Bonus (more detailed for tiles we're looking at)
    if (angleDiff < 30) priority += 3;
    else if (angleDiff < 60) priority += 2;
    else if (angleDiff < 90) priority += 1;

    // 2. Distance Penalty (lower priority for far tiles)
    const distancePenalty = Math.min(distance * 0.5, 2);
    priority -= distancePenalty;

    // 3. Pitch Bonus (higher priority for tiles in front when pitched)
    if (pitch > 45 && angleDiff < 90) {
        priority += (pitch - 45) / 45 * 2;  // Up to +2 bonus at max pitch
    }

    // 4. Movement Prediction
    if (this.lastMapState) {
        const bearingDelta = Math.abs(bearing - this.lastMapState.bearing);
        if (bearingDelta > 2) {  // If rotating
            // Predict next view direction and boost those tiles
            const predictedAngle = (bearing + bearingDelta) % 360;
            const predictedAngleDiff = Math.abs(tileAngle - predictedAngle);
            if (predictedAngleDiff < 45) priority += 1;
        }
    }

    // 5. Cache Status Factor
    const tileKey = `${z}/${x}/${y}`;
    if (!terrainCache.has(tileKey) && !pendingTiles.has(tileKey)) {
        priority += 0.5;  // Slight boost for uncached tiles
    }

    // 6. Zoom Level Transitions
    const currentZoom = map.getZoom();
    const zoomDiff = Math.abs(z - currentZoom);
    if (zoomDiff < 1) priority += 1;  // Boost tiles at current zoom level

    // Keep priority in reasonable bounds
    return Math.max(0, Math.min(priority, 15));
},

   tile2lat(y, z) {
       const n = Math.PI - (2 * Math.PI * y) / Math.pow(2, z);
       return (180 / Math.PI) * Math.atan(0.5 * (Math.exp(n) - Math.exp(-n)));
   },

   reprioritizeQueue() {
       this.queue = this.queue.map(item => ({
           ...item,
           priority: this.calculatePriority(
               item.data.zoom,
               item.data.x,
               item.data.y
           )
       })).sort((a, b) => b.priority - a.priority);
   },

   addToQueue(data, priority = 0) {
       const queueItem = { 
           data, 
           priority: priority || this.calculatePriority(data.zoom, data.x, data.y),
           timestamp: Date.now() 
       };
       
       this.queue.push(queueItem);
       
       if (this.queue.length > this.queueLimit) {
           this.queue.sort((a, b) => {
               if (a.priority !== b.priority) return b.priority - a.priority;
               return a.timestamp - b.timestamp;
           });
           this.queue = this.queue.slice(0, this.queueLimit);
       }
       
       this.processQueue();
   },

    processQueue() {
        const batchSize = 4;
        while (this.queue.length > 0) {
            const availableWorkers = this.busy.filter(b => !b).length;
            if (availableWorkers === 0) break;

            const batch = this.queue.splice(0, Math.min(batchSize, availableWorkers));
            batch.forEach(({ data }) => {
                const worker = this.getAvailableWorker();
                if (worker) worker.postMessage(data);
            });
        }
    },

    preloadAdjacentTiles(z, x, y) {
        const adjacent = [
            {x: x-1, y: y, p: 1}, {x: x+1, y: y, p: 1},
            {x: x, y: y-1, p: 1}, {x: x, y: y+1, p: 1},
            {x: x-1, y: y-1, p: 0.5}, {x: x+1, y: y-1, p: 0.5},
            {x: x-1, y: y+1, p: 0.5}, {x: x+1, y: y+1, p: 0.5}
        ];
        
        adjacent.forEach(tile => {
            const tileKey = `${z}/${tile.x}/${tile.y}`;
            if (!terrainCache.has(tileKey) && !pendingTiles.has(tileKey)) {
                this.addToQueue({ zoom: z, x: tile.x, y: tile.y }, tile.p * this.calculatePriority(z, tile.x, tile.y));
            }
        });
    },

   postMessage(data) {
       const worker = this.getAvailableWorker();
       if (worker) {
           worker.postMessage(data);
           return true;
       }
       this.addToQueue(data);
       return true;
   },

   terminate() {
       this.workers.forEach(worker => worker.terminate());
       this.workers = [];
       this.busy = [];
       this.queue = [];
   }
};

map.on('move', () => {
    workerPool.lastMapState = {
        bearing: map.getBearing(),
        pitch: map.getPitch(),
        zoom: map.getZoom(),
        center: map.getCenter()
    };
});

// Modified fetch interceptor
const originalFetch = window.fetch;
window.fetch = async function(input, options) {
    try {
        let url, pathname;
        if (typeof input === 'string') {
            url = new URL(input, window.location.origin);
            pathname = url.pathname;
        } else if (input instanceof Request) {
            url = new URL(input.url, window.location.origin);
            pathname = url.pathname;
        } else {
            return originalFetch(input, options);
        }

        const terrainTileMatch = pathname.match(/\/terrain_(\d+)_(\d+)_(\d+)\.png$/);
        const contourTileMatch = pathname.match(/\/contours_(\d+)_(\d+)_(\d+)\.pbf$/);

        if (terrainTileMatch) {
            const [_, z, x, y] = terrainTileMatch.map(Number);
            const tileKey = `${z}/${x}/${y}`;

            if (terrainCache.has(tileKey)) {
                return new Response(terrainCache.get(tileKey), { 
                    headers: { 'Content-Type': 'image/png' } 
                });
            }

            if (pendingTiles.has(tileKey)) {
                return pendingTiles.get(tileKey).promise
                    .then(blob => new Response(blob, { headers: { 'Content-Type': 'image/png' } }))
                    .catch(() => originalFetch(input, options));
            }

            const { promise, resolve, reject } = await new Promise((res) => {
                let resolveTile, rejectTile;
                const tilePromise = new Promise((resolve, reject) => {
                    resolveTile = resolve;
                    rejectTile = reject;
                });
                res({ promise: tilePromise, resolve: resolveTile, reject: rejectTile });
            });

            pendingTiles.set(tileKey, { resolve, reject, promise });
            
            if (!workerPool.postMessage({ zoom: z, x: x, y: y })) {
                reject(new Error('No workers available'));
                return originalFetch(input, options);
            }

            try {
                const blob = await promise;
                if (terrainCache.size >= DEM_TILE_CACHE_LIMIT) {
                    const oldestKey = terrainCache.keys().next().value;
                    terrainCache.delete(oldestKey);
                }
                terrainCache.set(tileKey, blob);
                return new Response(blob, { headers: { 'Content-Type': 'image/png' } });
            } catch (error) {
                return originalFetch(input, options);
            }
        }

        return originalFetch(input, options);
    } catch (error) {
        return originalFetch(input, options);
    }
};

// Initialize the worker pool
workerPool.initialize();

// Clean up when page unloads
window.addEventListener('unload', () => {
    workerPool.terminate();
});



// Add Navigation Control
map.addControl(new maplibregl.NavigationControl({ visualizePitch: true }));

// Layer Control UI Functionality
function toggleLayer(layerId, checkboxId) {
    const checkbox = document.getElementById(checkboxId);
    if (map.getLayer(layerId)) {
        map.setLayoutProperty(layerId, 'visibility', checkbox.checked ? 'visible' : 'none');
    }
}

// Add a control panel section for Sentinel-2 layer adjustments
const layerControl = document.querySelector('.layer-control');
const sentinel2Controls = document.createElement('div');
sentinel2Controls.innerHTML = `
    <strong>Sentinel-2 Controls</strong>
    <label>Opacity: 
        <input type="range" id="sentinel-opacity" min="0" max="1" step="0.1" value="0.7">
        <span id="opacity-value">0.7</span>
    </label>
    <label>Contrast: 
        <input type="range" id="sentinel-contrast" min="-1" max="1" step="0.1" value="0.2">
        <span id="contrast-value">0.2</span>
    </label>
    <label>Saturation: 
        <input type="range" id="sentinel-saturation" min="-1" max="1" step="0.1" value="0.1">
        <span id="saturation-value">0.1</span>
    </label>
`;
layerControl.appendChild(sentinel2Controls);

// Event Listeners
document.getElementById('orthophotos-checkbox').addEventListener('change', () => {
    toggleLayer('orthophotos-layer', 'orthophotos-checkbox');
});

document.getElementById('snow-checkbox').addEventListener('change', () => {
    toggleLayer('Snow-layer', 'snow-checkbox');
});

document.getElementById('planIGN-checkbox').addEventListener('change', () => {
    toggleLayer('planIGN-layer', 'planIGN-checkbox');
});

// Add event listeners for the controls
document.getElementById('sentinel-opacity').addEventListener('input', (e) => {
    const value = parseFloat(e.target.value);
    map.setPaintProperty('sentinel2-layer', 'raster-opacity', value);
    document.getElementById('opacity-value').textContent = value.toFixed(1);
});

document.getElementById('sentinel-contrast').addEventListener('input', (e) => {
    const value = parseFloat(e.target.value);
    map.setPaintProperty('sentinel2-layer', 'raster-contrast', value);
    document.getElementById('contrast-value').textContent = value.toFixed(1);
});

document.getElementById('sentinel-saturation').addEventListener('input', (e) => {
    const value = parseFloat(e.target.value);
    map.setPaintProperty('sentinel2-layer', 'raster-saturation', value);
    document.getElementById('saturation-value').textContent = value.toFixed(1);
});

// Update the existing sentinel2 checkbox event listener to show/hide controls
document.getElementById('sentinel2-checkbox').addEventListener('change', (e) => {
    toggleLayer('sentinel2-layer', 'sentinel2-checkbox');
    sentinel2Controls.style.display = e.target.checked ? 'block' : 'none';
});

// Initially hide the controls
sentinel2Controls.style.display = 'none';
document.getElementById('buildings-checkbox').addEventListener('change', (e) => {
    const visibility = e.target.checked ? 'visible' : 'none';
    map.setLayoutProperty('3d-buildings', 'visibility', visibility);
});
document.getElementById('contours-checkbox').addEventListener('change', (e) => {
const visibility = e.target.checked ? 'visible' : 'none';
map.setLayoutProperty('contours', 'visibility', visibility);
map.setLayoutProperty('contour-text', 'visibility', visibility);
});
document.getElementById('hd-terrain-checkbox').addEventListener('change', (e) => {
    const isHD = e.target.checked;
    const loading = document.getElementById('loading');

    // Update terrain source
    map.setTerrain({
        source: isHD ? 'terrain-source' : 'dem',
        exaggeration: 1.0
    });

    // Remove and re-add the hillshade layer with the new source
    if (map.getLayer('hillshade-layer')) {
        map.removeLayer('hillshade-layer');
    }

    // Add hillshade layer back with the new source
    map.addLayer({
        id: 'hillshade-layer',
        type: 'hillshade',
        source: isHD ? 'terrain-source' : 'dem',
        layout: {visibility: 'visible'},
        paint: {
                'hillshade-exaggeration': 0.15,
                'hillshade-illumination-anchor':'map',
                'hillshade-illumination-direction':280
            }
    });

    map.once('idle', () => {
        loading.style.display = 'none';
    });
});
</script>
</body>
</html>